{"version":3,"file":"index.js","sources":["../../../../src/store/fvtt/document/EmbeddedStoreManager.ts","../../../../src/store/fvtt/document/TJSDocument.ts","../../../../src/store/fvtt/document/TJSDocumentCollection.ts"],"sourcesContent":["import { DynMapReducer }      from '#runtime/svelte/store/reducer';\r\n\r\nimport { isDocument }         from '#runtime/types/fvtt-shim/guard';\r\n\r\nimport {\r\n   hasPrototype,\r\n   isObject }                 from '#runtime/util/object';\r\n\r\nimport type { DynReducer }    from '#runtime/svelte/store/reducer';\r\n\r\nimport type { TJSDocument }   from './TJSDocument';\r\n\r\n/**\r\n * Provides management of reactive embedded collections.\r\n *\r\n * @privateRemarks\r\n * TODO: Consider subscribing to TJSDocument rather than exposing {@link EmbeddedStoreManager.handleDocChange} and\r\n * {@link EmbeddedStoreManager.handleUpdate}\r\n */\r\nexport class EmbeddedStoreManager implements TJSDocument.API.Embedded {\r\n   /**\r\n    * RegExp for detecting CRUD updates for the associated document.\r\n    */\r\n   static #updateActionRegex: RegExp = /(?<action>create|delete|update)(?<sep>\\.?)(?<name>\\w+)/;\r\n\r\n   /**\r\n    */\r\n   #name: Map<string, EmbeddedCollectionData<unknown>> = new Map();\r\n\r\n   /**\r\n    * Source document.\r\n    */\r\n   readonly #document: (fvtt.Document | undefined)[];\r\n\r\n   /**\r\n    * Reverse lookup for older Foundry versions.\r\n    */\r\n   #collectionToDocName: Map<string, string> = new Map();\r\n\r\n   /**\r\n    * Valid embedded collection actions.\r\n    */\r\n   #embeddedNames: Set<string> = new Set();\r\n\r\n   /**\r\n    * @param document - The associated document holder.\r\n    */\r\n   constructor(document: (fvtt.Document | undefined)[]) {\r\n      this.#document = document;\r\n\r\n      this.handleDocChange();\r\n\r\n      Object.seal(this);\r\n   }\r\n\r\n   /**\r\n    * Create a reactive embedded collection store. When no options are provided the name of the embedded collection\r\n    * matches the document name.\r\n    *\r\n    * @param FoundryDoc - A Foundry document.\r\n    *\r\n    * @param [options] - Dynamic reducer create options.\r\n    *\r\n    * @typeParam D `Foundry Document`.\r\n    *\r\n    * @typeParam O `CreateOptions` - Embedded API create options.\r\n    */\r\n   create<D extends fvtt.DocumentConstructor, O extends TJSDocument.API.Embedded.CreateOptions<InstanceType<D>>>(\r\n    FoundryDoc: D, options?: O):\r\n      O extends typeof DynMapReducer<string, InstanceType<D>>\r\n         ? InstanceType<O>\r\n         : O extends { ctor: typeof DynMapReducer<string, InstanceType<D>> }\r\n            ? InstanceType<O['ctor']>\r\n            : DynMapReducer<string, InstanceType<D>>\r\n   {\r\n      const docName: string = FoundryDoc?.documentName;\r\n\r\n      if (typeof docName !== 'string')\r\n      {\r\n         throw new TypeError(\r\n          `EmbeddedStoreManager.create error: 'FoundryDoc' does not have a valid 'documentName' property.`);\r\n      }\r\n\r\n      const doc: fvtt.Document | undefined = this.#document[0];\r\n\r\n      let collection: Map<string, InstanceType<D>> | null = null;\r\n\r\n      if (doc)\r\n      {\r\n         try\r\n         {\r\n            collection = doc.getEmbeddedCollection(docName) as unknown as Map<string, InstanceType<D>>;\r\n         }\r\n         catch (err)\r\n         {\r\n            console.warn(`EmbeddedStoreManager.create error: No valid embedded collection for: ${docName}`);\r\n         }\r\n      }\r\n\r\n      let embeddedData: EmbeddedCollectionData<any> | undefined = this.#name.get(docName);\r\n\r\n      if (!embeddedData)\r\n      {\r\n         embeddedData = {\r\n            collection,\r\n            stores: new Map<string, DynMapReducer<string, InstanceType<D>>>()\r\n         };\r\n\r\n         this.#name.set(docName, embeddedData);\r\n      }\r\n\r\n      /**\r\n       * Reducer name\r\n       */\r\n      let name: string | undefined;\r\n\r\n      /**\r\n       * Rest of common reducer options.\r\n       */\r\n      let rest: DynReducer.Options.Common<D> = {};\r\n\r\n      /**\r\n       * Reducer constructor function.\r\n       */\r\n      let ctor: typeof DynMapReducer<string, InstanceType<D>>;\r\n\r\n      if (typeof options === 'string')\r\n      {\r\n         name = options;\r\n         ctor = DynMapReducer;\r\n      }\r\n      else if (typeof options === 'function' && hasPrototype(options, DynMapReducer))\r\n      {\r\n         ctor = options as typeof DynMapReducer;\r\n      }\r\n      else if (isObject(options))\r\n      {\r\n         ({ name, ctor = DynMapReducer, ...rest as DynReducer.Options.Common<InstanceType<D>> } = options);\r\n      }\r\n      else\r\n      {\r\n         name = docName;\r\n         ctor = DynMapReducer;\r\n      }\r\n\r\n      if (!hasPrototype(ctor, DynMapReducer))\r\n      {\r\n         throw new TypeError(`EmbeddedStoreManager.create error: 'ctor' is not a 'DynMapReducer'.`);\r\n      }\r\n\r\n      name = name ?? ctor?.name;\r\n\r\n      if (typeof name !== 'string')\r\n      {\r\n         throw new TypeError(`EmbeddedStoreManager.create error: 'name' is not a string.`);\r\n      }\r\n\r\n      // A bit funky here. I have not figured out the right guards to satisfy the complex return type.\r\n      type CreateReturnType = O extends typeof DynMapReducer<string, InstanceType<D>>\r\n      ? InstanceType<O>\r\n      : O extends { ctor: typeof DynMapReducer<string, InstanceType<D>> }\r\n          ? InstanceType<O['ctor']>\r\n          : DynMapReducer<string, InstanceType<D>>;\r\n\r\n      if (embeddedData.stores.has(name))\r\n      {\r\n         return embeddedData.stores.get(name) as CreateReturnType;\r\n      }\r\n      else\r\n      {\r\n         const reducerOptions = collection ? { data: collection, ...rest } : { ...rest };\r\n         const instance = new ctor(reducerOptions as DynReducer.Options.MapReducer<string, InstanceType<D>>);\r\n         embeddedData.stores.set(name, instance);\r\n\r\n         // Invoke protected initialize method.\r\n         if (typeof (instance as any)?.initialize === 'function') { (instance as any).initialize(rest); }\r\n\r\n         return instance as CreateReturnType;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Destroys one or more embedded collection reducers. When no `reducerName` is provided all reactive embedded\r\n    * collections are destroyed for the given document type.\r\n    *\r\n    * @param FoundryDoc - A Foundry document class constructor.\r\n    *\r\n    * @param [reducerName] - Optional name of a specific reducer to destroy.\r\n    *\r\n    * @typeParam D `Foundry Document`.\r\n    */\r\n   destroy<D extends fvtt.DocumentConstructor>(FoundryDoc?: D, reducerName?: string): boolean\r\n   {\r\n      let count: number = 0;\r\n\r\n      // Destroy all embedded stores\r\n      if (FoundryDoc === void 0)\r\n      {\r\n         for (const embeddedData of this.#name.values())\r\n         {\r\n            embeddedData.collection = null;\r\n            for (const store of embeddedData.stores.values())\r\n            {\r\n               store.destroy();\r\n               count++;\r\n            }\r\n         }\r\n\r\n         this.#name.clear();\r\n      }\r\n      else\r\n      {\r\n         const docName: string = FoundryDoc?.documentName;\r\n\r\n         if (typeof docName !== 'string')\r\n         {\r\n            throw new TypeError(\r\n             `EmbeddedStoreManager.delete error: 'FoundryDoc' does not have a valid 'documentName' property.`);\r\n         }\r\n\r\n         if (reducerName === void 0)\r\n         {\r\n            const embeddedData: EmbeddedCollectionData<unknown> | undefined = this.#name.get(docName);\r\n            if (embeddedData)\r\n            {\r\n               embeddedData.collection = null;\r\n               for (const store of embeddedData.stores.values())\r\n               {\r\n                  store.destroy();\r\n                  count++;\r\n               }\r\n            }\r\n\r\n            this.#name.delete(docName);\r\n         }\r\n         else if (reducerName === 'string')\r\n         {\r\n            const embeddedData: EmbeddedCollectionData<unknown> | undefined = this.#name.get(docName);\r\n            if (embeddedData)\r\n            {\r\n               const store: DynMapReducer<string, any> | undefined = embeddedData.stores.get(reducerName);\r\n               if (store)\r\n               {\r\n                  store.destroy();\r\n                  count++;\r\n               }\r\n            }\r\n         }\r\n      }\r\n\r\n      return count > 0;\r\n   }\r\n\r\n   /**\r\n    * Returns a specific existing embedded collection store. When no `reducerName` is provided the document name\r\n    * is used instead.\r\n    *\r\n    * @param FoundryDoc - A Foundry document class constructor.\r\n    *\r\n    * @param [reducerName] - Optional name of a specific reducer to get.\r\n    *\r\n    * @typeParam D `Foundry Document`.\r\n    *\r\n    * @returns The associated reactive embedded collection / reducer.\r\n    */\r\n   get<D extends fvtt.DocumentConstructor>(FoundryDoc: D, reducerName?: string):\r\n    DynMapReducer<string, InstanceType<D>> | undefined\r\n   {\r\n      const docName = FoundryDoc?.documentName;\r\n\r\n      if (typeof docName !== 'string')\r\n      {\r\n         throw new TypeError(\r\n          `EmbeddedStoreManager.get error: 'FoundryDoc' does not have a valid 'documentName' property.`);\r\n      }\r\n\r\n      const embeddedData: EmbeddedCollectionData<any> | undefined = this.#name.get(docName);\r\n\r\n      if (embeddedData)\r\n      {\r\n         return embeddedData.stores.get(reducerName ?? docName);\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Updates all existing embedded collection stores with the associated embedded collection\r\n    */\r\n   handleDocChange(): void\r\n   {\r\n      const doc: fvtt.Document | undefined = this.#document[0];\r\n\r\n      if (isDocument(doc))\r\n      {\r\n         const existingEmbeddedNames = new Set(this.#name.keys());\r\n\r\n         /**\r\n          * All embedded names from associated document.\r\n          */\r\n         const embeddedNames: [string, string][] = Object.entries(\r\n          (doc.constructor as fvtt.DocumentConstructor)?.metadata?.embedded ?? []);\r\n\r\n         this.#collectionToDocName.clear();\r\n\r\n         // Remove all previously stored embedded name CRUD keys.\r\n         this.#embeddedNames.clear();\r\n\r\n         for (const [docName, collectionName] of embeddedNames)\r\n         {\r\n            // Remove processed embedded doc name from existingEmbeddedNames set.\r\n            existingEmbeddedNames.delete(docName);\r\n\r\n            // Update CRUD keys for v10.\r\n            this.#embeddedNames.add(`create${docName}`);\r\n            this.#embeddedNames.add(`delete${docName}`);\r\n            this.#embeddedNames.add(`update${docName}`);\r\n\r\n            // Update CRUD keys for v11.\r\n            this.#embeddedNames.add(`create.${collectionName}`);\r\n            this.#embeddedNames.add(`delete.${collectionName}`);\r\n            this.#embeddedNames.add(`update.${collectionName}`);\r\n\r\n            // Update CRUD keys for v12.\r\n            this.#embeddedNames.add(`create${collectionName}`);\r\n            this.#embeddedNames.add(`delete${collectionName}`);\r\n            this.#embeddedNames.add(`update${collectionName}`);\r\n\r\n            // v10 collection to doc name lookup.\r\n            this.#collectionToDocName.set(docName, docName);\r\n            this.#collectionToDocName.set(collectionName, docName);\r\n\r\n            let collection: fvtt.EmbeddedCollection | null = null;\r\n\r\n            try\r\n            {\r\n               // Update any existing stores with the actual collection.\r\n               collection = doc.getEmbeddedCollection(docName);\r\n            }\r\n            catch (err)\r\n            {\r\n               console.warn(`EmbeddedStoreManager.handleDocUpdate error: No valid embedded collection for: ${docName}`);\r\n            }\r\n\r\n            // Update EmbeddedData for new collection.\r\n            const embeddedData = this.#name.get(docName);\r\n            if (embeddedData)\r\n            {\r\n                  // A bit funky here, but Foundry collections modify the Map type.\r\n                  embeddedData.collection = collection as unknown as Map<string, unknown>;\r\n\r\n               // Update all existing stores.\r\n               for (const store of embeddedData.stores.values())\r\n               {\r\n                  store.setData(embeddedData.collection, true);\r\n               }\r\n            }\r\n         }\r\n\r\n         // Update all existing embedded collections with null data that aren't processed above.\r\n         for (const embeddedName of existingEmbeddedNames)\r\n         {\r\n            const embeddedData = this.#name.get(embeddedName);\r\n            if (embeddedData)\r\n            {\r\n               embeddedData.collection = null;\r\n\r\n               for (const store of embeddedData.stores.values()) { store.setData(null, true); }\r\n            }\r\n         }\r\n      }\r\n      else // Reset all embedded reducer stores to null data.\r\n      {\r\n         this.#collectionToDocName.clear();\r\n         this.#embeddedNames.clear();\r\n\r\n         for (const embeddedData of this.#name.values())\r\n         {\r\n            embeddedData.collection = null;\r\n\r\n            for (const store of embeddedData.stores.values()) { store.setData(null, true); }\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Handles updates to embedded stores parsing the document update action for valid embedded store types.\r\n    *\r\n    * On create, delete, update parse the type being modified then force index updates for the embedded type.\r\n    *\r\n    * @param action - Update action from document.\r\n    */\r\n   handleUpdate(action: string): void\r\n   {\r\n      if (!this.#embeddedNames.has(action)) { return; }\r\n\r\n      const match: RegExpExecArray | null = EmbeddedStoreManager.#updateActionRegex.exec(action);\r\n\r\n      if (match && match.groups)\r\n      {\r\n         const docOrCollectionName: string = match.groups.name;\r\n         const embeddedName: string | undefined = this.#collectionToDocName.get(docOrCollectionName);\r\n\r\n         const embeddedData: EmbeddedCollectionData<unknown> | undefined = this.#name.get(embeddedName!);\r\n\r\n         if (embeddedData)\r\n         {\r\n            for (const store of embeddedData.stores.values()) { store.index.update(true); }\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\n/**\r\n * Internal data stored for each collection and associated dynamic reducers.\r\n */\r\ntype EmbeddedCollectionData<D> = {\r\n  collection: Map<string, D> | null;\r\n\r\n  stores: Map<string, DynMapReducer<string, D>>\r\n};\r\n\r\n","import { tick }                     from 'svelte';\n\nimport { Hashing }                  from '#runtime/util';\n\nimport {\n   isObject,\n   isPlainObject }                  from '#runtime/util/object';\n\nimport { isDocument }               from '#runtime/types/fvtt-shim/guard';\n\nimport { EmbeddedStoreManager }     from './EmbeddedStoreManager';\n\nimport type {\n   Readable,\n   Subscriber,\n   Unsubscriber }                   from 'svelte/store';\n\nimport type {\n   DynMapReducer,\n   DynReducer }                     from '#runtime/svelte/store/reducer';\n\n/**\n * Provides a wrapper implementing the Svelte store / subscriber protocol around any Document / ClientMixinDocument.\n * This makes documents reactive in a Svelte component, but otherwise provides subscriber functionality external to\n * Svelte.\n *\n * @typeParam D `Foundry Document`.\n */\n\nclass TJSDocument<D extends fvtt.ClientDocument> implements Readable<D>\n{\n   /**\n    * Fake Application API that ClientDocumentMixin uses for document model callbacks.\n    */\n   #callbackAPI: CallbackAPI;\n\n   /**\n    * Wrapped document.\n    */\n   #document: (D | undefined)[] = [void 0];\n\n   /**\n    *\n    */\n   #embeddedStoreManager: EmbeddedStoreManager | undefined;\n\n   /**\n    *\n    */\n   #embeddedAPI: TJSDocument.API.Embedded | undefined;\n\n   /**\n    * UUIDv4 assigned to this instance.\n    */\n   readonly #uuidv4: string;\n\n   /**\n    *\n    */\n   #options: TJSDocument.Options.Config<D> = {};\n\n   /**\n    * All current subscribers.\n    */\n   #subscribers: TJSDocument.SubscriberFn<D>[] = [];\n\n   /**\n    * Latest update options processed.\n    */\n   #updateOptions: TJSDocument.Data.Update | undefined;\n\n   /**\n    * @param [document] - Document to wrap or TJSDocumentOptions.\n    *\n    * @param [options] - TJSDocument options.\n    */\n   constructor(document?: D | TJSDocument.Options.Config<D>, options: TJSDocument.Options.Config<D> = {})\n   {\n      this.#uuidv4 = `tjs-document-${Hashing.uuidv4()}`;\n\n      this.#callbackAPI = {\n         close: this.#deleted.bind(this),\n         render: this.#updateSubscribers.bind(this)\n      };\n\n      if (isPlainObject(document)) // Handle case when only options are passed into ctor.\n      {\n         this.setOptions(document);\n      }\n      else\n      {\n         this.setOptions(options);\n         this.set(document as D);\n      }\n   }\n\n   /**\n    * @returns {import('./types').EmbeddedAPI} Embedded store manager.\n    */\n   get embedded()\n   {\n      if (!this.#embeddedAPI)\n      {\n         this.#embeddedStoreManager = new EmbeddedStoreManager(this.#document);\n\n         this.#embeddedAPI = {\n            create: (doc, options) => this.#embeddedStoreManager!.create(doc, options),\n            destroy: (doc, storeName) => this.#embeddedStoreManager!.destroy(doc, storeName),\n            get: (doc, storeName) => this.#embeddedStoreManager!.get(doc, storeName)\n         };\n      }\n\n      return this.#embeddedAPI;\n   }\n\n   /**\n    * @returns Returns the options passed on last update.\n    */\n   get updateOptions(): TJSDocument.Data.Update\n   {\n      return this.#updateOptions ?? { action: 'unknown', data: [] };\n   }\n\n   /**\n    * @returns Returns the UUIDv4 assigned to this store.\n    */\n   get uuidv4(): string { return this.#uuidv4; }\n\n   /**\n    * Register the callback API with the underlying Foundry document.\n    */\n   #callbackRegister(): void\n   {\n      const doc: D | undefined = this.#document[0];\n      if (isDocument(doc) && isObject(doc?.apps) && !doc.apps[this.#uuidv4])\n      {\n         doc.apps[this.#uuidv4] = this.#callbackAPI;\n      }\n   }\n\n   /**\n    * Unregister the callback API with the underlying Foundry document.\n    */\n   #callbackUnregister(): void\n   {\n      const doc: D | undefined = this.#document[0];\n      if (isDocument(doc))\n      {\n         delete doc?.apps?.[this.#uuidv4];\n      }\n   }\n\n   /**\n    * Handles cleanup when the document is deleted. Invoking any optional delete function set in the constructor.\n    *\n    * @returns Promise when completed.\n    */\n   async #deleted(): Promise<void>\n   {\n      const doc: D | undefined = this.#document[0];\n\n      // Check to see if the document is still in the associated collection to determine if actually deleted.\n      if (isDocument(doc) && !doc?.collection?.has(doc.id))\n      {\n         this.#setDocument(void 0);\n\n         if (typeof this.#options.preDelete === 'function') { await this.#options.preDelete(doc); }\n\n         this.#updateSubscribers(false, { action: 'delete' });\n\n         if (typeof this.#options.delete === 'function') { await this.#options.delete(doc); }\n\n         // Allow subscribers to be able to query `updateOptions` involving any reactive statements.\n         await tick();\n\n         this.#updateOptions = void 0;\n      }\n   }\n\n   /**\n    * Completely removes all internal subscribers, any optional delete callback, and unregisters from the\n    * ClientDocumentMixin `apps` tracking object.\n    */\n   destroy(): void\n   {\n      if (this.#embeddedStoreManager)\n      {\n         this.#embeddedStoreManager.destroy();\n         this.#embeddedStoreManager = void 0;\n         this.#embeddedAPI = void 0;\n      }\n\n      this.#setDocument(void 0);\n\n      this.#options.delete = void 0;\n      this.#options.preDelete = void 0;\n\n      this.#subscribers.length = 0;\n   }\n\n   /**\n    * @returns Current document\n    */\n   get(): D | undefined { return this.#document[0]; }\n\n   /**\n    * Attempts to create a Foundry UUID from standard drop data. This may not work for all systems.\n    *\n    * @param data - Drop transfer data.\n    *\n    * @param [opts] - Optional parameters.\n    *\n    * @param [opts.compendium=true] - Accept compendium documents.\n    *\n    * @param [opts.world=true] - Accept world documents.\n    *\n    * @param [opts.types] - Require the `data.type` to match entry in `types`.\n    *\n    * @returns Foundry UUID for drop data.\n    */\n   static getUUIDFromDataTransfer(data: TJSDocument.Data.UUIDDataTransfer,\n    { compendium = true, world = true, types = void 0 }: TJSDocument.Options.UUIDFromDataTransfer = {}):\n     string | undefined\n   {\n      if (!isObject(data)) { return void 0; }\n\n      if (Array.isArray(types) && !types.includes(data.type!)) { return void 0; }\n\n      let uuid: string | undefined = void 0;\n\n      if (typeof data.uuid === 'string') // v10 and above provides a full UUID.\n      {\n         const isCompendium: boolean = data.uuid.startsWith('Compendium');\n\n         if (isCompendium && compendium)\n         {\n            uuid = data.uuid;\n         }\n         else if (world)\n         {\n            uuid = data.uuid;\n         }\n      }\n\n      return uuid;\n   }\n\n   /**\n    * Sets a new document target to be monitored. To unset use `undefined` or `null`.\n    *\n    * @param doc - New document to set.\n    *\n    * @param [options] - New document update options to set.\n    */\n   set(doc: D | undefined | null, options: Partial<TJSDocument.Data.Update> = {}): void\n   {\n      if (doc !== void 0 && doc !== null && !isDocument(doc))\n      {\n         throw new TypeError(`TJSDocument set error: 'document' is not a valid Document or undefined / null.`);\n      }\n\n      if (!isObject(options))\n      {\n         throw new TypeError(`TJSDocument set error: 'options' is not an object.`);\n      }\n\n      // Only post an update if the document has changed.\n      if (this.#setDocument(doc))\n      {\n         // Only add registration if there are current subscribers.\n         if (isDocument(doc) && this.#subscribers.length)\n         {\n            this.#callbackRegister();\n         }\n\n         this.#updateSubscribers(false, {\n            ...options,\n            action: `tjs-set-${doc === void 0 || doc === null ? 'undefined' : 'new'}`\n         });\n      }\n   }\n\n   /**\n    * Internally sets the new document being tracked.\n    *\n    * @param doc -\n    *\n    * @returns {boolean} Whether the document changed.\n    */\n   #setDocument(doc: D | undefined | null): boolean\n   {\n      const changed: boolean = doc !== this.#document[0];\n\n      // Unregister before setting new document state.\n      if (changed) { this.#callbackUnregister(); }\n\n      this.#document[0] = doc === void 0 || doc === null ? void 0 : doc;\n\n      if (changed && this.#embeddedStoreManager) { this.#embeddedStoreManager.handleDocChange(); }\n\n      return changed;\n   }\n\n   /**\n    * Potentially sets new document from data transfer object.\n    *\n    * @param data - Document transfer data.\n    *\n    * @param [options] - Optional parameters for {@link TJSDocument.getUUIDFromDataTransfer}.\n    *\n    * @returns Returns true if new document set from data transfer blob.\n    */\n   async setFromDataTransfer(data: TJSDocument.Data.UUIDDataTransfer,\n    options?: TJSDocument.Options.UUIDFromDataTransfer): Promise<boolean>\n   {\n      return this.setFromUUID(TJSDocument.getUUIDFromDataTransfer(data, options));\n   }\n\n   /**\n    * Sets the document by Foundry UUID performing a lookup and setting the document if found.\n    *\n    * @param {string}   uuid - A Foundry UUID to lookup.\n    *\n    * @param {import('./types').TJSDocumentUpdateOptions}   [options] - New document update options to set.\n    *\n    * @returns {Promise<boolean>} True if successfully set document from UUID.\n    */\n   async setFromUUID(uuid?: string, options?: TJSDocument.Data.Update): Promise<boolean>\n   {\n      if (typeof uuid !== 'string' || uuid.length === 0) { return false; }\n\n      try\n      {\n         const doc: fvtt.ClientDocument = await (globalThis as any).fromUuid(uuid);\n\n         if (doc)\n         {\n            this.set(doc, options);\n            return true;\n         }\n      }\n      catch (err) { /**/ }\n\n      return false;\n   }\n\n   /**\n    * Sets options for this document wrapper / store.\n    *\n    * @param options - Options for TJSDocument.\n    */\n   setOptions(options: TJSDocument.Options.Config<D>): void\n   {\n      if (!isObject(options))\n      {\n         throw new TypeError(`TJSDocument error: 'options' is not a plain object.`);\n      }\n\n      // Verify valid values -------------\n\n      if (options.delete !== void 0 && options.delete !== null && typeof options.delete !== 'function')\n      {\n         throw new TypeError(`TJSDocument error: 'delete' attribute in options is not a function or null.`);\n      }\n\n      if (options.preDelete !== void 0 && options.preDelete !== null && typeof options.preDelete !== 'function')\n      {\n         throw new TypeError(`TJSDocument error: 'preDelete' attribute in options is not a function or null.`);\n      }\n\n      // Set any valid values -------------\n\n      if (options.delete !== void 0)\n      {\n         this.#options.delete = options.delete as TJSDocument.Options.Config<D>['delete'] ?? void 0;\n      }\n\n      if (options.preDelete !== void 0)\n      {\n         this.#options.preDelete = options.preDelete as TJSDocument.Options.Config<D>['preDelete'] ?? void 0;\n      }\n   }\n\n   /**\n    * @param handler - Callback function that is invoked on update / changes.\n    *\n    * @returns Unsubscribe function.\n    */\n   subscribe(handler: TJSDocument.SubscriberFn<D>): Unsubscriber\n   {\n      let addedSubscriber = false;\n\n      const currentIdx = this.#subscribers.findIndex((entry) => entry === handler);\n      if (currentIdx === -1)\n      {\n         this.#subscribers.push(handler);\n         addedSubscriber = true;\n      }\n\n      if (addedSubscriber)\n      {\n         // Register callback with first subscriber.\n         if (this.#subscribers.length === 1) { this.#callbackRegister(); }\n\n         const updateOptions = { action: 'tjs-subscribe', data: [] };\n\n         handler(this.#document[0], updateOptions);      // Call handler with current value and update options.\n      }\n\n      // Return unsubscribe function.\n      return () =>\n      {\n         const index = this.#subscribers.findIndex((sub) => sub === handler);\n         if (index !== -1) { this.#subscribers.splice(index, 1); }\n\n         // Unsubscribe from document callback if there are no subscribers.\n         if (this.#subscribers.length === 0) { this.#callbackUnregister(); }\n      };\n   }\n\n   /**\n    * @param [force] - unused - signature from Foundry render function.\n    *\n    * @param [options] - Options from render call; will have document update context.\n    */\n   #updateSubscribers(force: boolean, options: Record<string, unknown> = {}): void // eslint-disable-line no-unused-vars\n   {\n      // Shallow copy w/ remapped keys.\n      const optionsRemap: TJSDocument.Data.Update = {\n         action: (options.action ?? options.renderContext ?? 'tjs-unknown') as string,\n         data: (options.data ?? options.renderData ?? []) as []\n      };\n\n      // Coerce `data` as necessary into an array to standardize receiving processing.\n      if (!Array.isArray(optionsRemap.data)) { optionsRemap.data = [optionsRemap.data]; }\n\n      this.#updateOptions = optionsRemap;\n\n      const subscribers = this.#subscribers;\n      const doc = this.#document[0];\n\n      for (let cntr = 0; cntr < subscribers.length; cntr++) { subscribers[cntr](doc, optionsRemap); }\n\n      if (this.#embeddedStoreManager)\n      {\n         this.#embeddedStoreManager.handleUpdate(optionsRemap.action);\n      }\n   }\n}\n\ntype CallbackAPI = { close: Function, render: Function };\n\ndeclare namespace TJSDocument {\n   /**\n    * Subscriber handler function to receive updates.\n    */\n   export interface SubscriberFn<D extends fvtt.ClientDocument> extends Subscriber<D> {\n      (value: D | undefined, options?: Data.Update): void;\n   }\n\n   export namespace API {\n      /**\n       * Provides the public embedded reactive collection API.\n       */\n      export interface Embedded {\n         /**\n          * Create a reactive embedded collection store. When no options are provided the name of the embedded\n          * collection matches the document name.\n          *\n          * @param FoundryDoc - A Foundry document class constructor.\n          *\n          * @param [options] - Dynamic reducer create options.\n          *\n          * @typeParam D `Foundry Document`.\n          *\n          * @typeParam O `CreateOptions` - Embedded API create options.\n          */\n         create<D extends fvtt.DocumentConstructor, O extends Embedded.CreateOptions<InstanceType<D>>>(\n            FoundryDoc: D, options?: O):\n            O extends typeof DynMapReducer<string, InstanceType<D>>\n               ? InstanceType<O>\n               : O extends { ctor: typeof DynMapReducer<string, InstanceType<D>> }\n                  ? InstanceType<O['ctor']>\n                  : DynMapReducer<string, InstanceType<D>>;\n\n         /**\n          * Destroys one or more embedded collection reducers. When no `reducerName` is provided all reactive embedded\n          * collections are destroyed for the given document type.\n          *\n          * @param FoundryDoc - A Foundry document class constructor.\n          *\n          * @param [reducerName] - Optional name of a specific reducer to destroy.\n          *\n          * @typeParam D `Foundry Document`.\n          */\n         destroy<D extends fvtt.DocumentConstructor>(FoundryDoc?: D, reducerName?: string): boolean;\n\n         /**\n          * Returns a specific existing embedded collection store. When no `reducerName` is provided the document name\n          * is used instead.\n          *\n          * @param FoundryDoc - A Foundry document class constructor.\n          *\n          * @param [reducerName] - Optional name of a specific reducer to get.\n          *\n          * @typeParam D `Foundry Document`.\n          *\n          * @returns The associated reactive embedded collection / reducer.\n          */\n         get<D extends fvtt.DocumentConstructor>(FoundryDoc: D, reducerName?: string):\n          DynMapReducer<string, InstanceType<D>> | undefined;\n      }\n\n      export namespace Embedded {\n         /**\n          * Creates a compound type for embedded collection map reducer 'create' option combinations.\n          *\n          * Includes additional type inference constraints for {@link DynReducer.Data.MapCreate} requiring either\n          * `ctor` or `sort` / `filters` to be defined.\n          *\n          * @typeParam D `Foundry Document` - Instance type of Foundry document.\n          */\n         export type CreateOptions<D> =\n            | string\n            | typeof DynMapReducer<string, D>\n            | (DynReducer.Data.MapCreate<string, D> & { ctor: typeof DynMapReducer<string, D> })\n            | (DynReducer.Data.MapCreate<string, D> & (\n               | { filters: Iterable<DynReducer.Data.FilterFn<D> | DynReducer.Data.Filter<D>> }\n               | { sort: DynReducer.Data.CompareFn<D> | DynReducer.Data.Sort<D> }\n            ));\n      }\n   }\n\n   export namespace Data {\n      /**\n       * Defines the shape of the data transfer object for {@link TJSDocument.getUUIDFromDataTransfer}.\n       */\n      interface UUIDDataTransfer {\n         /**\n          * The type of the document (\"item\", \"actor\").\n          */\n         type?: string;\n\n         /**\n          * The Foundry UUID if available\n          */\n         uuid?: string;\n\n         /**\n          * Extra properties.\n          */\n         [key: string]: any;\n      }\n\n      /**\n       * Provides data regarding the latest document change / update.\n       */\n      export interface Update {\n         /**\n          * The update action. Useful for filtering.\n          */\n         action: string;\n\n         /**\n          * Foundry data associated with document changes.\n          */\n         data: { [key: string]: unknown }[] | string[];\n      }\n   }\n\n   export namespace Options {\n      interface Config<D extends fvtt.ClientDocument> {\n         /**\n          * Optional post-delete function to invoke when document is deleted _after_ subscribers have been notified.\n          *\n          * @param doc Document being deleted.\n          */\n         delete?: ((doc?: D) => void | Promise<void>);\n\n         /**\n          * Optional pre-delete function to invoke when document is deleted _before_ subscribers are notified.\n          *\n          * @param doc Document being deleted.\n          */\n         preDelete?: ((doc?: D) => void | Promise<void>);\n      }\n\n      /**\n       * Options for the {@link TJSDocument.getUUIDFromDataTransfer} and {@link TJSDocument.setFromDataTransfer}\n       * methods.\n       */\n      export interface UUIDFromDataTransfer {\n         /**\n          * Accept compendium documents.\n          */\n         compendium?: boolean;\n\n         /**\n          * Accept world documents.\n          */\n         world?: boolean;\n\n         /**\n          * Require the `data.type` to match an entry in `types`.\n          */\n         types?: string[];\n      }\n   }\n}\n\nexport { TJSDocument }\n","import { tick }                  from 'svelte';\n\nimport { Hashing }               from '#runtime/util';\n\nimport {\n   isObject,\n   isPlainObject }               from '#runtime/util/object';\n\nimport { isDocumentCollection }  from '#runtime/types/fvtt-shim/guard';\n\nimport type {\n   Readable,\n   Subscriber,\n   Unsubscriber }                from 'svelte/store';\n\ntype CallbackAPI = { uuid: string, close: Function, render: Function };\n\n/**\n * Provides a wrapper implementing the Svelte store / subscriber protocol around any DocumentCollection. This makes\n * document collections reactive in a Svelte component, but otherwise provides subscriber functionality external to\n * Svelte.\n *\n * @typeParam C `Foundry Collection`.\n */\nclass TJSDocumentCollection<C extends fvtt.DocumentCollection> implements Readable<C>\n{\n   /**\n    * Fake Application API that DocumentCollection uses for document model callbacks.\n    */\n   readonly #callbackAPI: CallbackAPI;\n\n   /**\n    * Collection being wrapped.\n    */\n   #collection: C | undefined = void 0;\n\n   /**\n    * UUIDv4 to associate as key with wrapped collection.\n    */\n   readonly #uuidv4: string;\n\n   /**\n    * Configuration options.\n    */\n   #options: TJSDocumentCollection.Options.Config<C> = {};\n\n   /**\n    * All current subscribers.\n    */\n   #subscribers: TJSDocumentCollection.SubscriberFn<C>[] = [];\n\n   /**\n    * Latest update options processed.\n    */\n   #updateOptions: TJSDocumentCollection.Data.Update | undefined;\n\n   /**\n    * @param [collection] - Collection to wrap or TJSDocumentCollectionOptions.\n    *\n    * @param [options] - TJSDocumentCollection options.\n    */\n   constructor(collection?: C | TJSDocumentCollection.Options.Config<C>,\n    options: TJSDocumentCollection.Options.Config<C> = {})\n   {\n      this.#uuidv4 = `tjs-collection-${Hashing.uuidv4()}`;\n\n      this.#callbackAPI = {\n         uuid: this.#uuidv4,\n         close: this.#deleted.bind(this),\n         render: this.#updateSubscribers.bind(this)\n      };\n\n      if (isPlainObject(collection)) // Handle case when only options are passed into ctor.\n      {\n         this.setOptions(collection);\n      }\n      else\n      {\n         this.setOptions(options);\n         this.set(collection as C);\n      }\n   }\n\n   /**\n    * Returns the options passed on last update.\n    *\n    * @returns Last update options.\n    */\n   get updateOptions(): TJSDocumentCollection.Data.Update\n   {\n      return this.#updateOptions ?? { action: 'unknown', data: [] };\n   }\n\n   /**\n    * Returns the UUIDv4 assigned to this store.\n    *\n    * @returns UUIDv4\n    */\n   get uuid(): string { return this.#uuidv4; }\n\n   /**\n    * Register the callback API with the underlying Foundry collection.\n    */\n   #callbackRegister()\n   {\n      const collection: C | undefined = this.#collection;\n\n      if (isDocumentCollection(collection) && Array.isArray(collection?.apps))\n      {\n         const index: number = collection.apps.findIndex((sub: CallbackAPI): boolean => sub === this.#callbackAPI);\n         if (index === -1) { collection.apps.push(this.#callbackAPI); }\n      }\n   }\n\n   /**\n    * Unregister the callback API with the underlying Foundry collection.\n    */\n   #callbackUnregister()\n   {\n      const collection: C | undefined = this.#collection;\n\n      if (isDocumentCollection(this.#collection) && Array.isArray(collection?.apps))\n      {\n         const index = collection.apps.findIndex((sub: CallbackAPI): boolean => sub === this.#callbackAPI);\n         if (index >= 0) { collection.apps.splice(index, 1); }\n      }\n   }\n\n   /**\n    * Handles cleanup when the collection is deleted. Invoking any optional delete function set in the constructor.\n    *\n    * @returns {Promise<void>}\n    */\n   async #deleted(): Promise<void>\n   {\n      const collection: C | undefined = this.#collection;\n\n      this.#callbackUnregister();\n\n      this.#collection = void 0;\n\n      // Only invoke handlers and subscribers if the collection was defined.\n      if (collection)\n      {\n         if (typeof this.#options.preDelete === 'function') { await this.#options.preDelete(collection); }\n\n         this.#updateSubscribers(false, { action: 'delete' });\n\n         if (typeof this.#options.delete === 'function') { await this.#options.delete(collection); }\n      }\n\n      // Allow subscribers to be able to query `updateOptions` involving any reactive statements.\n      await tick();\n\n      this.#updateOptions = void 0;\n   }\n\n   /**\n    * Completely removes all internal subscribers, any optional delete callback, and unregisters from the\n    * DocumentCollection `apps` tracking array.\n    */\n   destroy(): void\n   {\n      this.#callbackUnregister();\n      this.#collection = void 0;\n\n      this.#options.delete = void 0;\n      this.#options.preDelete = void 0;\n\n      this.#subscribers.length = 0;\n   }\n\n   /**\n    * @returns Current collection if any.\n    */\n   get(): C | undefined { return this.#collection; }\n\n   /**\n    * Sets a new document collection target to be monitored. To unset use `undefined` or `null`.\n    *\n    * @param collection - New collection to set.\n    *\n    * @param [options] - New collection update options to set.\n    */\n   set(collection: C | undefined | null, options: Partial<TJSDocumentCollection.Data.Update> = {}): void\n   {\n      if (collection !== void 0 && collection !== null && !isDocumentCollection(collection))\n      {\n         throw new TypeError(\n          `TJSDocumentCollection set error: 'collection' is not a valid DocumentCollection or undefined.`);\n      }\n\n      if (!isObject(options))\n      {\n         throw new TypeError(`TJSDocument set error: 'options' is not an object.`);\n      }\n\n      const changed: boolean = this.#collection !== collection;\n\n      if (changed) { this.#callbackUnregister(); }\n\n      this.#collection = collection === void 0 || collection === null ? void 0 : collection;\n\n      if (changed)\n      {\n         if (isDocumentCollection(collection) && this.#subscribers.length) { this.#callbackRegister(); }\n\n         this.#updateSubscribers(false, {\n            data: [],\n            ...options,\n            action: `tjs-set-${collection === void 0 || collection === null ? 'undefined' : 'new'}`\n         });\n      }\n   }\n\n   /**\n    * Sets options for this collection wrapper / store.\n    *\n    * @param options - Options for TJSDocumentCollection.\n    */\n   setOptions(options: TJSDocumentCollection.Options.Config<C>): void\n   {\n      if (!isObject(options))\n      {\n         throw new TypeError(`TJSDocumentCollection error: 'options' is not an object.`);\n      }\n\n      // Verify valid values -------------\n\n      if (options.delete !== void 0 && options.delete !== null && typeof options.delete !== 'function')\n      {\n         throw new TypeError(`TJSDocumentCollection error: 'delete' attribute in options is not a function or null.`);\n      }\n\n      if (options.preDelete !== void 0 && options.preDelete !== null && typeof options.preDelete !== 'function')\n      {\n         throw new TypeError(\n          `TJSDocumentCollection error: 'preDelete' attribute in options is not a function or null.`);\n      }\n\n      // Set any valid values -------------\n\n\n      if (options.delete !== void 0)\n      {\n         this.#options.delete = options.delete as TJSDocumentCollection.Options.Config<C>['delete'] ?? void 0;\n      }\n\n      if (options.preDelete !== void 0)\n      {\n         this.#options.preDelete = options.delete as TJSDocumentCollection.Options.Config<C>['preDelete'] ?? void 0;\n      }\n   }\n\n   /**\n    * @param handler - Callback function that is invoked on update / changes.\n    *\n    * @returns Unsubscribe function.\n    */\n   subscribe(handler: TJSDocumentCollection.SubscriberFn<C>): Unsubscriber\n   {\n      let addedSubscriber: boolean = false;\n\n      const currentIdx: number = this.#subscribers.findIndex(\n       (entry: TJSDocumentCollection.SubscriberFn<C>): boolean => entry === handler);\n\n      if (currentIdx === -1)\n      {\n         this.#subscribers.push(handler);\n         addedSubscriber = true;\n      }\n\n      if (addedSubscriber)\n      {\n         // Register callback with first subscriber.\n         if (this.#subscribers.length === 1) { this.#callbackRegister(); }\n\n         const collection: C | undefined = this.#collection;\n\n         const updateOptions = { action: 'tjs-subscribe', data: [] };\n\n         handler(collection, updateOptions);  // Call handler with current value and update options.\n      }\n\n      // Return unsubscribe function.\n      return (): void =>\n      {\n         const index: number = this.#subscribers.findIndex(\n          (sub: TJSDocumentCollection.SubscriberFn<C>): boolean => sub === handler);\n\n         if (index !== -1) { this.#subscribers.splice(index, 1); }\n\n         // Unsubscribe from collection if there are no subscribers.\n         if (this.#subscribers.length === 0) { this.#callbackUnregister(); }\n      };\n   }\n\n   /**\n    * @param force - unused - signature from Foundry render function.\n    *\n    * @param [options] - Options from render call; will have collection update context.\n    */\n   #updateSubscribers(force: boolean, options: Record<string, unknown> = {}): void // eslint-disable-line no-unused-vars\n   {\n      // Shallow copy w/ remapped keys.\n      const optionsRemap: TJSDocumentCollection.Data.Update = {\n         action: (options.action ?? options.renderContext ?? 'tjs-unknown') as string,\n         data: (options.data ?? options.renderData ?? []) as []\n      };\n\n      // Coerce `data` as necessary into an array to standardize receiving processing.\n      if (!Array.isArray(optionsRemap.data)) { optionsRemap.data = [optionsRemap.data]; }\n\n      this.#updateOptions = optionsRemap;\n\n      const subscribers: TJSDocumentCollection.SubscriberFn<C>[] = this.#subscribers;\n      const collection: C | undefined = this.#collection;\n\n      for (let cntr: number = 0; cntr < subscribers.length; cntr++) { subscribers[cntr](collection, optionsRemap); }\n   }\n}\n\nnamespace TJSDocumentCollection {\n   /**\n    * Subscriber handler function to receive updates.\n    */\n   export interface SubscriberFn<C extends fvtt.DocumentCollection> extends Subscriber<C> {\n      (value: C | undefined, options?: Data.Update): void;\n   }\n\n   export namespace Data {\n      /**\n       * Provides data regarding the latest collection change / update.\n       */\n      export interface Update {\n         /**\n          * The update action. Useful for filtering.\n          */\n         action: string;\n\n         /**\n          * Foundry data associated with document changes.\n          */\n         data: { [key: string]: unknown }[] | string[];\n      }\n   }\n\n   export namespace Options {\n      export interface Config<C extends fvtt.DocumentCollection> {\n         /**\n          * Optional post-delete function to invoke when document is deleted _after_ subscribers have been notified.\n          *\n          * @param collection Document collecting being deleted.\n          */\n         delete?: ((collection: C) => void | Promise<void>);\n\n         /**\n          * Optional pre-delete function to invoke when document is deleted _before_ subscribers are notified.\n          *\n          * @param collection Document collecting being deleted.\n          */\n         preDelete?: ((collection: C) => void | Promise<void>);\n      }\n   }\n}\n\nexport { TJSDocumentCollection }\n"],"names":[],"mappings":"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"}