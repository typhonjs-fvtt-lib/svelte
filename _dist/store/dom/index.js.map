{"version":3,"file":"index.js","sources":["../../../node_modules/svelte/internal/index.mjs","../../../../../typhonjs-svelte/lib/_dist/util/index.js","../../../../../typhonjs-svelte/lib/_dist/store/dom/index.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\nfunction is_promise(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\nfunction split_css_unit(value) {\n    const split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n    return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];\n}\nconst contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction comment(content) {\n    return document.createComment(content);\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_immediate_propagation(fn) {\n    return function (event) {\n        event.stopImmediatePropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction set_dynamic_element_data(tag) {\n    return (/-/.test(tag)) ? set_custom_element_data_map : set_attributes;\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction init_binding_group(group) {\n    let _inputs;\n    return {\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            _inputs.forEach(input => group.push(input));\n        },\n        /* remove */ r() {\n            _inputs.forEach(input => group.splice(group.indexOf(input), 1));\n        }\n    };\n}\nfunction init_binding_group_dynamic(group, indexes) {\n    let _group = get_binding_group(group);\n    let _inputs;\n    function get_binding_group(group) {\n        for (let i = 0; i < indexes.length; i++) {\n            group = group[indexes[i]] = group[indexes[i]] || [];\n        }\n        return group;\n    }\n    function push() {\n        _inputs.forEach(input => _group.push(input));\n    }\n    function remove() {\n        _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));\n    }\n    return {\n        /* update */ u(new_indexes) {\n            indexes = new_indexes;\n            const new_group = get_binding_group(group);\n            if (new_group !== _group) {\n                remove();\n                _group = new_group;\n                push();\n            }\n        },\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            push();\n        },\n        /* remove */ r: remove\n    };\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction claim_comment(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 8, (node) => {\n        node.data = '' + data;\n        return undefined;\n    }, () => comment(data), true);\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    text.data = data;\n}\nfunction set_data_contenteditable(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable(text, data);\n    }\n    else {\n        set_data(text, data);\n    }\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value, mounting) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    if (!mounting || value !== undefined) {\n        select.selectedIndex = -1; // no option should be selected\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked');\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n            // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n            // see https://github.com/sveltejs/svelte/issues/4233\n            fn();\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            /** #7364  target for <template> may be provided as #document-fragment(11) */\n            else\n                this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));\n            this.t = target.tagName !== 'TEMPLATE' ? target : target.content;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nlet render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n        return;\n    }\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        try {\n            while (flushidx < dirty_components.length) {\n                const component = dirty_components[flushidx];\n                flushidx++;\n                set_current_component(component);\n                update(component.$$);\n            }\n        }\n        catch (e) {\n            // reset dirty state to not end up in a deadlocked state and then rethrow\n            dirty_components.length = 0;\n            flushidx = 0;\n            throw e;\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n */\nfunction flush_render_callbacks(fns) {\n    const filtered = [];\n    const targets = [];\n    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n    targets.forEach((c) => c());\n    render_callbacks = filtered;\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    const options = { direction: 'in' };\n    let config = fn(node, params, options);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config(options);\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    const options = { direction: 'out' };\n    let config = fn(node, params, options);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config(options);\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    const options = { direction: 'both' };\n    let config = fn(node, params, options);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro  we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro  needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config(options);\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    const updates = [];\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            // defer updates until all the DOM shuffling is done\n            updates.push(() => block.p(child_ctx, dirty));\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    run_all(updates);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\nconst _boolean_attributes = [\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n];\n/**\n * List of HTML boolean attributes (e.g. `<input disabled>`).\n * Source: https://html.spec.whatwg.org/multipage/indices.html\n */\nconst boolean_attributes = new Set([..._boolean_attributes]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        flush_render_callbacks($$.after_update);\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.58.0' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    if (has_stop_immediate_propagation)\n        modifiers.push('stopImmediatePropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_contenteditable_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable_dev(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable_dev(text, data);\n    }\n    else {\n        set_data_dev(text, data);\n    }\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_comment, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, comment, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, contenteditable_truthy_values, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, flush_render_callbacks, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, head_selector, identity, init, init_binding_group, init_binding_group_dynamic, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_data_contenteditable, set_data_contenteditable_dev, set_data_dev, set_data_maybe_contenteditable, set_data_maybe_contenteditable_dev, set_dynamic_element_data, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, split_css_unit, spread, src_url_equal, start_hydrating, stop_immediate_propagation, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","import { group_outros, transition_out, check_outros } from 'svelte/internal';\n\n/**\r\n * Provides common object manipulation utilities including depth traversal, obtaining accessors, safely setting values /\r\n * equality tests, and validation.\r\n */\r\n\r\nconst s_TAG_OBJECT = '[object Object]';\r\n\r\n/**\r\n * Recursively deep merges all source objects into the target object in place. Like `Object.assign` if you provide `{}`\r\n * as the target a copy is produced. If the target and source property are object literals they are merged.\r\n * Deleting keys is supported by specifying a property starting with `-=`.\r\n *\r\n * @param {object}      target - Target object.\r\n *\r\n * @param {...object}   sourceObj - One or more source objects.\r\n *\r\n * @returns {object}    Target object.\r\n */\r\nfunction deepMerge(target = {}, ...sourceObj)\r\n{\r\n   if (Object.prototype.toString.call(target) !== s_TAG_OBJECT)\r\n   {\r\n      throw new TypeError(`deepMerge error: 'target' is not an 'object'.`);\r\n   }\r\n\r\n   for (let cntr = 0; cntr < sourceObj.length; cntr++)\r\n   {\r\n      if (Object.prototype.toString.call(sourceObj[cntr]) !== s_TAG_OBJECT)\r\n      {\r\n         throw new TypeError(`deepMerge error: 'sourceObj[${cntr}]' is not an 'object'.`);\r\n      }\r\n   }\r\n\r\n   return _deepMerge(target, ...sourceObj);\r\n}\r\n\r\n/**\r\n * Tests for whether an object is iterable.\r\n *\r\n * @param {*} value - Any value.\r\n *\r\n * @returns {boolean} Whether object is iterable.\r\n */\r\nfunction isIterable(value)\r\n{\r\n   if (value === null || value === void 0 || typeof value !== 'object') { return false; }\r\n\r\n   return typeof value[Symbol.iterator] === 'function';\r\n}\r\n\r\n/**\r\n * Tests for whether an object is async iterable.\r\n *\r\n * @param {*} value - Any value.\r\n *\r\n * @returns {boolean} Whether value is async iterable.\r\n */\r\nfunction isIterableAsync(value)\r\n{\r\n   if (value === null || value === void 0 || typeof value !== 'object') { return false; }\r\n\r\n   return typeof value[Symbol.asyncIterator] === 'function';\r\n}\r\n\r\n/**\r\n * Tests for whether object is not null and a typeof object.\r\n *\r\n * @param {*} value - Any value.\r\n *\r\n * @returns {boolean} Is it an object.\r\n */\r\nfunction isObject(value)\r\n{\r\n   return value !== null && typeof value === 'object';\r\n}\r\n\r\n/**\r\n * Tests for whether the given value is a plain object.\r\n *\r\n * An object is plain if it is created by either: `{}`, `new Object()` or `Object.create(null)`.\r\n *\r\n * @param {*} value - Any value\r\n *\r\n * @returns {boolean} Is it a plain object.\r\n */\r\nfunction isPlainObject(value)\r\n{\r\n   if (Object.prototype.toString.call(value) !== s_TAG_OBJECT) { return false; }\r\n\r\n   const prototype = Object.getPrototypeOf(value);\r\n   return prototype === null || prototype === Object.prototype;\r\n}\r\n\r\n/**\r\n * Provides a way to safely access an objects data / entries given an accessor string which describes the\r\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\r\n * to walk.\r\n *\r\n * @param {object}   data - An object to access entry data.\r\n *\r\n * @param {string}   accessor - A string describing the entries to access.\r\n *\r\n * @param {*}        defaultValue - (Optional) A default value to return if an entry for accessor is not found.\r\n *\r\n * @returns {object} The data object.\r\n */\r\nfunction safeAccess(data, accessor, defaultValue = void 0)\r\n{\r\n   if (typeof data !== 'object') { return defaultValue; }\r\n   if (typeof accessor !== 'string') { return defaultValue; }\r\n\r\n   const access = accessor.split('.');\r\n\r\n   // Walk through the given object by the accessor indexes.\r\n   for (let cntr = 0; cntr < access.length; cntr++)\r\n   {\r\n      // If the next level of object access is undefined or null then return the empty string.\r\n      if (typeof data[access[cntr]] === 'undefined' || data[access[cntr]] === null) { return defaultValue; }\r\n\r\n      data = data[access[cntr]];\r\n   }\r\n\r\n   return data;\r\n}\r\n\r\n/**\r\n * Provides a way to safely set an objects data / entries given an accessor string which describes the\r\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\r\n * to walk.\r\n *\r\n * @param {object}   data - An object to access entry data.\r\n *\r\n * @param {string}   accessor - A string describing the entries to access.\r\n *\r\n * @param {*}        value - A new value to set if an entry for accessor is found.\r\n *\r\n * @param {string}   [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\r\n *                                       'set-undefined', 'sub'.\r\n *\r\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\r\n *                                          automatically.\r\n *\r\n * @returns {boolean} True if successful.\r\n */\r\nfunction safeSet(data, accessor, value, operation = 'set', createMissing = true)\r\n{\r\n   if (typeof data !== 'object') { throw new TypeError(`safeSet Error: 'data' is not an 'object'.`); }\r\n   if (typeof accessor !== 'string') { throw new TypeError(`safeSet Error: 'accessor' is not a 'string'.`); }\r\n\r\n   const access = accessor.split('.');\r\n\r\n   // Walk through the given object by the accessor indexes.\r\n   for (let cntr = 0; cntr < access.length; cntr++)\r\n   {\r\n      // If data is an array perform validation that the accessor is a positive integer otherwise quit.\r\n      if (Array.isArray(data))\r\n      {\r\n         const number = (+access[cntr]);\r\n\r\n         if (!Number.isInteger(number) || number < 0) { return false; }\r\n      }\r\n\r\n      if (cntr === access.length - 1)\r\n      {\r\n         switch (operation)\r\n         {\r\n            case 'add':\r\n               data[access[cntr]] += value;\r\n               break;\r\n\r\n            case 'div':\r\n               data[access[cntr]] /= value;\r\n               break;\r\n\r\n            case 'mult':\r\n               data[access[cntr]] *= value;\r\n               break;\r\n\r\n            case 'set':\r\n               data[access[cntr]] = value;\r\n               break;\r\n\r\n            case 'set-undefined':\r\n               if (typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = value; }\r\n               break;\r\n\r\n            case 'sub':\r\n               data[access[cntr]] -= value;\r\n               break;\r\n         }\r\n      }\r\n      else\r\n      {\r\n         // If createMissing is true and the next level of object access is undefined then create a new object entry.\r\n         if (createMissing && typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = {}; }\r\n\r\n         // Abort if the next level is null or not an object and containing a value.\r\n         if (data[access[cntr]] === null || typeof data[access[cntr]] !== 'object') { return false; }\r\n\r\n         data = data[access[cntr]];\r\n      }\r\n   }\r\n\r\n   return true;\r\n}\r\n\r\n/**\r\n * Internal implementation for `deepMerge`.\r\n *\r\n * @param {object}      target - Target object.\r\n *\r\n * @param {...object}   sourceObj - One or more source objects.\r\n *\r\n * @returns {object}    Target object.\r\n */\r\nfunction _deepMerge(target = {}, ...sourceObj)\r\n{\r\n   // Iterate and merge all source objects into target.\r\n   for (let cntr = 0; cntr < sourceObj.length; cntr++)\r\n   {\r\n      const obj = sourceObj[cntr];\r\n\r\n      for (const prop in obj)\r\n      {\r\n         if (Object.prototype.hasOwnProperty.call(obj, prop))\r\n         {\r\n            // Handle the special property starting with '-=' to delete keys.\r\n            if (prop.startsWith('-='))\r\n            {\r\n               delete target[prop.slice(2)];\r\n               continue;\r\n            }\r\n\r\n            // If target already has prop and both target[prop] and obj[prop] are object literals then merge them\r\n            // otherwise assign obj[prop] to target[prop].\r\n            target[prop] = Object.prototype.hasOwnProperty.call(target, prop) && target[prop]?.constructor === Object &&\r\n            obj[prop]?.constructor === Object ? _deepMerge({}, target[prop], obj[prop]) : obj[prop];\r\n         }\r\n      }\r\n   }\r\n\r\n   return target;\r\n}\n\n/**\r\n * Provides several helpful utility methods for accessibility and keyboard navigation.\r\n */\r\nclass A11yHelper\r\n{\r\n   /**\r\n    * Apply focus to the HTMLElement targets in a given A11yFocusSource data object. An iterable list `options.focusEl`\r\n    * can contain HTMLElements or selector strings. If multiple focus targets are provided in a list then the first\r\n    * valid target found will be focused. If focus target is a string then a lookup via `document.querySelector` is\r\n    * performed. In this case you should provide a unique selector for the desired focus target.\r\n    *\r\n    * Note: The body of this method is postponed to the next clock tick to allow any changes in the DOM to occur that\r\n    * might alter focus targets before applying.\r\n    *\r\n    * @param {A11yFocusSource|{ focusSource: A11yFocusSource }}   options - The focus options instance to apply.\r\n    */\r\n   static applyFocusSource(options)\r\n   {\r\n      if (!isObject(options)) { return; }\r\n\r\n      // Handle the case of receiving an object with embedded `focusSource`.\r\n      const focusOpts = isObject(options?.focusSource) ? options.focusSource : options;\r\n\r\n      setTimeout(() =>\r\n      {\r\n         const debug = typeof focusOpts.debug === 'boolean' ? focusOpts.debug : false;\r\n\r\n         if (isIterable(focusOpts.focusEl))\r\n         {\r\n            if (debug)\r\n            {\r\n               console.debug(`A11yHelper.applyFocusSource debug - Attempting to apply focus target: `, focusOpts.focusEl);\r\n            }\r\n\r\n            for (const target of focusOpts.focusEl)\r\n            {\r\n               if (target instanceof HTMLElement && target.isConnected)\r\n               {\r\n                  target.focus();\r\n                  if (debug)\r\n                  {\r\n                     console.debug(`A11yHelper.applyFocusSource debug - Applied focus to target: `, target);\r\n                  }\r\n                  break;\r\n               }\r\n               else if (typeof target === 'string')\r\n               {\r\n                  const element = document.querySelector(target);\r\n                  if (element instanceof HTMLElement && element.isConnected)\r\n                  {\r\n                     element.focus();\r\n                     if (debug)\r\n                     {\r\n                        console.debug(`A11yHelper.applyFocusSource debug - Applied focus to target: `, element);\r\n                     }\r\n                     break;\r\n                  }\r\n                  else if (debug)\r\n                  {\r\n                     console.debug(`A11yHelper.applyFocusSource debug - Could not query selector: `, target);\r\n                  }\r\n               }\r\n            }\r\n         }\r\n         else if (debug)\r\n         {\r\n            console.debug(`A11yHelper.applyFocusSource debug - No focus targets defined.`);\r\n         }\r\n      }, 0);\r\n   }\r\n\r\n   /**\r\n    * Returns first focusable element within a specified element.\r\n    *\r\n    * @param {HTMLElement|Document} [element=document] - Optional element to start query.\r\n    *\r\n    * @param {object} [options] - Optional parameters.\r\n    *\r\n    * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.\r\n    *\r\n    * @param {Set<HTMLElement>} [options.ignoreElements] - Set of elements to ignore.\r\n    *\r\n    * @returns {HTMLElement} First focusable child element\r\n    */\r\n   static getFirstFocusableElement(element = document, options)\r\n   {\r\n      const focusableElements = this.getFocusableElements(element, options);\r\n\r\n      return focusableElements.length > 0 ? focusableElements[0] : void 0;\r\n   }\r\n\r\n   /**\r\n    * Returns all focusable elements within a specified element.\r\n    *\r\n    * @param {HTMLElement|Document} [element=document] Optional element to start query.\r\n    *\r\n    * @param {object}            [options] - Optional parameters.\r\n    *\r\n    * @param {boolean}           [options.anchorHref=true] - When true anchors must have an HREF.\r\n    *\r\n    * @param {Iterable<string>}  [options.ignoreClasses] - Iterable list of classes to ignore elements.\r\n    *\r\n    * @param {Set<HTMLElement>}  [options.ignoreElements] - Set of elements to ignore.\r\n    *\r\n    * @param {string}            [options.selectors] - Custom list of focusable selectors for `querySelectorAll`.\r\n    *\r\n    * @returns {Array<HTMLElement>} Child keyboard focusable\r\n    */\r\n   static getFocusableElements(element = document, { anchorHref = true, ignoreClasses, ignoreElements, selectors } = {})\r\n   {\r\n      if (!(element instanceof HTMLElement) && !(element instanceof Document))\r\n      {\r\n         throw new TypeError(`'element' is not a HTMLElement or Document instance.`);\r\n      }\r\n\r\n      if (typeof anchorHref !== 'boolean')\r\n      {\r\n         throw new TypeError(`'anchorHref' is not a boolean.`);\r\n      }\r\n\r\n      if (ignoreClasses !== void 0 && !isIterable(ignoreClasses))\r\n      {\r\n         throw new TypeError(`'ignoreClasses' is not an iterable list.`);\r\n      }\r\n\r\n      if (ignoreElements !== void 0 && !(ignoreElements instanceof Set))\r\n      {\r\n         throw new TypeError(`'ignoreElements' is not a Set.`);\r\n      }\r\n\r\n      if (selectors !== void 0 && typeof selectors !== 'string')\r\n      {\r\n         throw new TypeError(`'selectors' is not a string.`);\r\n      }\r\n\r\n      const selectorQuery = selectors ?? this.#getFocusableSelectors(anchorHref);\r\n\r\n      const allElements = [...element.querySelectorAll(selectorQuery)];\r\n\r\n      if (ignoreElements && ignoreClasses)\r\n      {\r\n         return allElements.filter((el) =>\r\n         {\r\n            let hasIgnoreClass = false;\r\n            for (const ignoreClass of ignoreClasses)\r\n            {\r\n               if (el.classList.contains(ignoreClass))\r\n               {\r\n                  hasIgnoreClass = true;\r\n                  break;\r\n               }\r\n            }\r\n\r\n            return !hasIgnoreClass && !ignoreElements.has(el) && el.style.display !== 'none' &&\r\n             el.style.visibility !== 'hidden' && !el.hasAttribute('disabled') && !el.hasAttribute('inert') &&\r\n              el.getAttribute('aria-hidden') !== 'true';\r\n         });\r\n      }\r\n      else if (ignoreClasses)\r\n      {\r\n         return allElements.filter((el) =>\r\n         {\r\n            let hasIgnoreClass = false;\r\n            for (const ignoreClass of ignoreClasses)\r\n            {\r\n               if (el.classList.contains(ignoreClass))\r\n               {\r\n                  hasIgnoreClass = true;\r\n                  break;\r\n               }\r\n            }\r\n\r\n            return !hasIgnoreClass && el.style.display !== 'none' && el.style.visibility !== 'hidden' &&\r\n             !el.hasAttribute('disabled') && !el.hasAttribute('inert') && el.getAttribute('aria-hidden') !== 'true';\r\n         });\r\n      }\r\n      else if (ignoreElements)\r\n      {\r\n         return allElements.filter((el) =>\r\n         {\r\n            return !ignoreElements.has(el) && el.style.display !== 'none' && el.style.visibility !== 'hidden' &&\r\n             !el.hasAttribute('disabled') && !el.hasAttribute('inert') && el.getAttribute('aria-hidden') !== 'true';\r\n         });\r\n      }\r\n      else\r\n      {\r\n         return allElements.filter((el) =>\r\n         {\r\n            return el.style.display !== 'none' && el.style.visibility !== 'hidden' && !el.hasAttribute('disabled') &&\r\n             !el.hasAttribute('inert') && el.getAttribute('aria-hidden') !== 'true';\r\n         });\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Returns the default focusable selectors query.\r\n    *\r\n    * @param {boolean}  [anchorHref=true] - When true anchors must have an HREF.\r\n    *\r\n    * @returns {string} Focusable selectors for `querySelectorAll`.\r\n    */\r\n   static #getFocusableSelectors(anchorHref = true)\r\n   {\r\n      return `button, [contenteditable=\"\"], [contenteditable=\"true\"], details summary:not([tabindex=\"-1\"]), embed, a${\r\n       anchorHref ? '[href]' : ''}, iframe, object, input:not([type=hidden]), select, textarea, ` +\r\n        `[tabindex]:not([tabindex=\"-1\"])`;\r\n   }\r\n\r\n   /**\r\n    * Gets a A11yFocusSource object from the given DOM event allowing for optional X / Y screen space overrides.\r\n    * Browsers (Firefox / Chrome) forwards a mouse event for the context menu keyboard button. Provides detection of\r\n    * when the context menu event is from the keyboard. Firefox as of (1/23) does not provide the correct screen space\r\n    * coordinates, so for keyboard context menu presses coordinates are generated from the centroid point of the\r\n    * element.\r\n    *\r\n    * A default fallback element or selector string may be provided to provide the focus target. If the event comes from\r\n    * the keyboard however the source focused element is inserted as the target with the fallback value appended to the\r\n    * list of focus targets. When A11yFocusSource is applied by {@link A11yHelper.applyFocusSource} the target focus\r\n    * list is iterated through until a connected target is found and focus applied.\r\n    *\r\n    * @param {object} options - Options\r\n    *\r\n    * @param {KeyboardEvent|MouseEvent}   [options.event] - The source DOM event.\r\n    *\r\n    * @param {boolean} [options.debug] - When true {@link A11yHelper.applyFocusSource} logs focus target data.\r\n    *\r\n    * @param {HTMLElement|string} [options.focusEl] - A specific HTMLElement or selector string as the focus target.\r\n    *\r\n    * @param {number}   [options.x] - Used when an event isn't provided; integer of event source in screen space.\r\n    *\r\n    * @param {number}   [options.y] - Used when an event isn't provided; integer of event source in screen space.\r\n    *\r\n    * @returns {A11yFocusSource} A A11yFocusSource object.\r\n    *\r\n    * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1426671\r\n    * @see https://bugzilla.mozilla.org/show_bug.cgi?id=314314\r\n    *\r\n    * TODO: Evaluate / test against touch input devices.\r\n    */\r\n   static getFocusSource({ event, x, y, focusEl, debug = false })\r\n   {\r\n      if (focusEl !== void 0 && !(focusEl instanceof HTMLElement) && typeof focusEl !== 'string')\r\n      {\r\n         throw new TypeError(\r\n          `A11yHelper.getFocusSource error: 'focusEl' is not a HTMLElement or string.`);\r\n      }\r\n\r\n      if (debug !== void 0 && typeof debug !== 'boolean')\r\n      {\r\n         throw new TypeError(`A11yHelper.getFocusSource error: 'debug' is not a boolean.`);\r\n      }\r\n\r\n      // Handle the case when no event is provided and x, y, or focusEl is explicitly defined.\r\n      if (event === void 0)\r\n      {\r\n         if (typeof x !== 'number')\r\n         {\r\n            throw new TypeError(`A11yHelper.getFocusSource error: 'event' not defined and 'x' is not a number.`);\r\n         }\r\n\r\n         if (typeof y !== 'number')\r\n         {\r\n            throw new TypeError(`A11yHelper.getFocusSource error: 'event' not defined and 'y' is not a number.`);\r\n         }\r\n\r\n         return {\r\n            debug,\r\n            focusEl: focusEl !== void 0 ? [focusEl] : void 0,\r\n            x,\r\n            y,\r\n         };\r\n      }\r\n\r\n      if (!(event instanceof KeyboardEvent) && !(event instanceof MouseEvent))\r\n      {\r\n         throw new TypeError(`A11yHelper.getFocusSource error: 'event' is not a KeyboardEvent or MouseEvent.`);\r\n      }\r\n\r\n      if (x !== void 0 && !Number.isInteger(x))\r\n      {\r\n         throw new TypeError(`A11yHelper.getFocusSource error: 'x' is not a number.`);\r\n      }\r\n\r\n      if (y !== void 0 && !Number.isInteger(y))\r\n      {\r\n         throw new TypeError(`A11yHelper.getFocusSource error: 'y' is not a number.`);\r\n      }\r\n\r\n      /** @type {HTMLElement} */\r\n      const targetEl = event.target;\r\n\r\n      if (!(targetEl instanceof HTMLElement))\r\n      {\r\n         throw new TypeError(`A11yHelper.getFocusSource error: 'event.target' is not an HTMLElement.`);\r\n      }\r\n\r\n      const result = { debug };\r\n\r\n      if (event instanceof MouseEvent)\r\n      {\r\n         // Firefox currently (1/23) does not correctly determine the location of a keyboard originated\r\n         // context menu location, so calculate position from middle of the event target.\r\n         // Firefox fires a mouse event for the context menu key.\r\n         if (event?.button !== 2 && event.type === 'contextmenu')\r\n         {\r\n            const rect = targetEl.getBoundingClientRect();\r\n            result.x = x ?? rect.left + (rect.width / 2);\r\n            result.y = y ?? rect.top + (rect.height / 2);\r\n            result.focusEl = focusEl !== void 0 ? [targetEl, focusEl] : [targetEl];\r\n            result.source = 'keyboard';\r\n         }\r\n         else\r\n         {\r\n            result.x = x ?? event.pageX;\r\n            result.y = y ?? event.pageY;\r\n            result.focusEl = focusEl !== void 0 ? [focusEl] : void 0;\r\n         }\r\n      }\r\n      else\r\n      {\r\n         const rect = targetEl.getBoundingClientRect();\r\n         result.x = x ?? rect.left + (rect.width / 2);\r\n         result.y = y ?? rect.top + (rect.height / 2);\r\n         result.focusEl = focusEl !== void 0 ? [targetEl, focusEl] : [targetEl];\r\n         result.source = 'keyboard';\r\n      }\r\n\r\n      return result;\r\n   }\r\n\r\n   /**\r\n    * Returns first focusable element within a specified element.\r\n    *\r\n    * @param {HTMLElement|Document} [element=document] - Optional element to start query.\r\n    *\r\n    * @param {object} [options] - Optional parameters.\r\n    *\r\n    * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.\r\n    *\r\n    * @param {Set<HTMLElement>} [options.ignoreElements] - Set of elements to ignore.\r\n    *\r\n    * @returns {HTMLElement} First focusable child element\r\n    */\r\n   static getLastFocusableElement(element = document, options)\r\n   {\r\n      const focusableElements = this.getFocusableElements(element, options);\r\n\r\n      return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : void 0;\r\n   }\r\n\r\n   /**\r\n    * Tests if the given element is focusable.\r\n    *\r\n    * @param {HTMLElement} [el] - Element to test.\r\n    *\r\n    * @param {object} [options] - Optional parameters.\r\n    *\r\n    * @param {boolean} [options.anchorHref=true] - When true anchors must have an HREF.\r\n    *\r\n    * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.\r\n    *\r\n    * @returns {boolean} Element is focusable.\r\n    */\r\n   static isFocusable(el, { anchorHref = true, ignoreClasses } = {})\r\n   {\r\n      if (el === void 0 || el === null || !(el instanceof HTMLElement) || el?.hidden || !el?.isConnected)\r\n      {\r\n         return false;\r\n      }\r\n\r\n      if (typeof anchorHref !== 'boolean')\r\n      {\r\n         throw new TypeError(`'anchorHref' is not a boolean.`);\r\n      }\r\n\r\n      if (ignoreClasses !== void 0 && !isIterable(ignoreClasses))\r\n      {\r\n         throw new TypeError(`'ignoreClasses' is not an iterable list.`);\r\n      }\r\n\r\n      const contenteditableAttr = el.getAttribute('contenteditable');\r\n      const contenteditableFocusable = typeof contenteditableAttr === 'string' &&\r\n       (contenteditableAttr === '' || contenteditableAttr === 'true');\r\n\r\n      const tabindexAttr = el.getAttribute('tabindex');\r\n      const tabindexFocusable = typeof tabindexAttr === 'string' && tabindexAttr !== '-1';\r\n\r\n      const isAnchor = el instanceof HTMLAnchorElement;\r\n\r\n      if (contenteditableFocusable || tabindexFocusable || isAnchor || el instanceof HTMLButtonElement ||\r\n       el instanceof HTMLDetailsElement || el instanceof HTMLEmbedElement || el instanceof HTMLIFrameElement ||\r\n        el instanceof HTMLInputElement || el instanceof HTMLObjectElement || el instanceof HTMLSelectElement ||\r\n         el instanceof HTMLTextAreaElement)\r\n      {\r\n         if (isAnchor && anchorHref && typeof el.getAttribute('href') !== 'string')\r\n         {\r\n            return false;\r\n         }\r\n\r\n         return el.style.display !== 'none' && el.style.visibility !== 'hidden' && !el.hasAttribute('disabled') &&\r\n          !el.hasAttribute('inert') && el.getAttribute('aria-hidden') !== 'true';\r\n      }\r\n\r\n      return false;\r\n   }\r\n\r\n   /**\r\n    * Convenience method to check if the given data is a valid focus source.\r\n    *\r\n    * @param {HTMLElement|string}   data - Either an HTMLElement or selector string.\r\n    *\r\n    * @returns {boolean} Is valid focus source.\r\n    */\r\n   static isFocusSource(data)\r\n   {\r\n      return data instanceof HTMLElement || typeof data === 'string';\r\n   }\r\n}\r\n\r\n/**\r\n * @typedef {object} A11yFocusSource - Provides essential data to return focus to an HTMLElement after a series of UI\r\n * actions like working with context menus and modal dialogs.\r\n *\r\n * @property {boolean} [debug] - When true logs to console the actions taken in {@link A11yHelper.applyFocusSource}.\r\n *\r\n * @property {Iterable<HTMLElement|string>} [focusEl] - List of targets to attempt to focus.\r\n *\r\n * @property {string} [source] - The source of the event: 'keyboard' for instance.\r\n *\r\n * @property {number} [x] - Potential X coordinate of initial event.\r\n *\r\n * @property {number} [y] - Potential Y coordinate of initial event.\r\n */\n\n/**\r\n * Provides management of a single Promise that can be shared and accessed across JS & Svelte components. This allows a\r\n * Promise to be created and managed as part of the TRL application lifecycle and accessed safely in various control\r\n * flow scenarios. When resolution of the current managed Promise starts further interaction is prevented.\r\n *\r\n * Note: to enable debugging / log statements set the static `logging` variable to true.\r\n */\r\nclass ManagedPromise\r\n{\r\n   /** @type {boolean} */\r\n   static #logging = false;\r\n\r\n   /** @type {{ isProcessing?: boolean, promise?: Promise, reject: Function, resolve: Function }} */\r\n   #current;\r\n\r\n   /**\r\n    * @returns {boolean} Whether global logging is enabled.\r\n    */\r\n   static get logging()\r\n   {\r\n      return this.#logging;\r\n   }\r\n\r\n   /**\r\n    * @returns {boolean} Whether there is an active managed Promise.\r\n    */\r\n   get isActive()\r\n   {\r\n      return this.#current !== void 0;\r\n   }\r\n\r\n   /**\r\n    * @returns {boolean} Whether there is an active managed Promise and resolution is currently being processed.\r\n    */\r\n   get isProcessing()\r\n   {\r\n      return this.#current !== void 0 ? this.#current.isProcessing : false;\r\n   }\r\n\r\n   /**\r\n    * Sets global logging enabled state.\r\n    *\r\n    * @param {boolean}  logging - New logging enabled state.\r\n    */\r\n   static set logging(logging)\r\n   {\r\n      if (typeof logging !== 'boolean')\r\n      {\r\n         throw new TypeError(`[TRL] ManagedPromise.logging error: 'logging' is not a boolean.`);\r\n      }\r\n\r\n      this.#logging = logging;\r\n   }\r\n\r\n   // ----------------------------------------------------------------------------------------------------------------\r\n\r\n   /**\r\n    * Resolves any current Promise with undefined and creates a new current Promise.\r\n    *\r\n    * @template T\r\n    *\r\n    * @param {object} opts - Options.\r\n    *\r\n    * @param {boolean}  [opts.reuse=false] - When true if there is an existing live Promise it is returned immediately.\r\n    *\r\n    * @returns {Promise<T>} The new current managed Promise.\r\n    */\r\n   create({ reuse = false } = {})\r\n   {\r\n      if (typeof reuse !== 'boolean')\r\n      {\r\n         throw new TypeError(`[TRL] ManagedPromise.create error: 'reuse' is not a boolean.`);\r\n      }\r\n\r\n      if (reuse && this.#current !== void 0 && this.#current.promise instanceof Promise)\r\n      {\r\n         if (ManagedPromise.#logging)\r\n         {\r\n            console.warn(`[TRL] ManagedPromise.create info: Reusing / returning existing managed Promise.`);\r\n         }\r\n\r\n         return this.#current.promise;\r\n      }\r\n\r\n      if (this.#current !== void 0)\r\n      {\r\n         if (ManagedPromise.#logging)\r\n         {\r\n            console.warn(\r\n             `[TRL] ManagedPromise.create info: Creating a new Promise and resolving existing immediately.`);\r\n         }\r\n\r\n         this.#current.resolve(void 0);\r\n         this.#current = void 0;\r\n      }\r\n\r\n      const promise = new Promise((resolve, reject) =>\r\n      {\r\n         this.#current = {\r\n            isProcessing: false,\r\n            reject,\r\n            resolve\r\n         };\r\n      });\r\n\r\n      this.#current.promise = promise;\r\n\r\n      return promise;\r\n   }\r\n\r\n   /**\r\n    * Gets the current Promise if any.\r\n    *\r\n    * @returns {Promise<any>} Current Promise.\r\n    */\r\n   get()\r\n   {\r\n      return this.#current ? this.#current.promise : void 0;\r\n   }\r\n\r\n   /**\r\n    * Rejects the current Promise if applicable.\r\n    *\r\n    * @param {*}  [result] - Result to reject.\r\n    *\r\n    * @returns {boolean} Was the promise rejected.\r\n    */\r\n   reject(result = void 0)\r\n   {\r\n      // Early out as Promise resolution is currently processing.\r\n      if (this.#current !== void 0 && this.#current.isProcessing)\r\n      {\r\n         if (ManagedPromise.#logging)\r\n         {\r\n            console.warn(`[TRL] ManagedPromise.reject info: Currently processing promise.`);\r\n         }\r\n\r\n         return true;\r\n      }\r\n\r\n      if (this.#current !== void 0)\r\n      {\r\n         this.#current.isProcessing = true;\r\n\r\n         if (result instanceof Promise)\r\n         {\r\n            result.then((value) =>\r\n            {\r\n               this.#current.reject(value);\r\n               this.#current = void 0;\r\n            }).catch((err) =>\r\n            {\r\n               this.#current.reject(err);\r\n               this.#current = void 0;\r\n            });\r\n         }\r\n         else\r\n         {\r\n            this.#current.reject(result);\r\n            this.#current = void 0;\r\n         }\r\n\r\n         return true;\r\n      }\r\n      else\r\n      {\r\n         if (ManagedPromise.#logging)\r\n         {\r\n            console.warn(`[TRL] ManagedPromise.reject warning: No current managed Promise to reject.`);\r\n         }\r\n\r\n         return false;\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Resolves the current Promise if applicable.\r\n    *\r\n    * @param {*}  [result] - Result to resolve.\r\n    *\r\n    * @returns {boolean} Was the promise resolved.\r\n    */\r\n   resolve(result = void 0)\r\n   {\r\n      // Early out as Promise resolution is currently processing.\r\n      if (this.#current !== void 0 && this.#current.isProcessing)\r\n      {\r\n         if (ManagedPromise.#logging)\r\n         {\r\n            console.warn(`[TRL] ManagedPromise.resolve info: Currently processing promise.`);\r\n         }\r\n\r\n         return true;\r\n      }\r\n\r\n      if (this.#current !== void 0)\r\n      {\r\n         if (result instanceof Promise)\r\n         {\r\n            this.#current.isProcessing = true;\r\n\r\n            result.then((value) =>\r\n            {\r\n               this.#current.resolve(value);\r\n               this.#current = void 0;\r\n            }).catch((err) =>\r\n            {\r\n               this.#current.reject(err);\r\n               this.#current = void 0;\r\n            });\r\n         }\r\n         else\r\n         {\r\n            this.#current.resolve(result);\r\n            this.#current = void 0;\r\n         }\r\n\r\n         return true;\r\n      }\r\n      else\r\n      {\r\n         if (ManagedPromise.#logging)\r\n         {\r\n            console.warn(`[TRL] ManagedPromise.resolve warning: No current managed Promise to resolve.`);\r\n         }\r\n\r\n         return false;\r\n      }\r\n   }\r\n}\n\n/**\r\n * Provides utility methods for checking browser capabilities.\r\n *\r\n * @see https://kilianvalkhof.com/2021/web/detecting-media-query-support-in-css-and-javascript/\r\n * TODO: perhaps add support for various standard media query checks for level 4 & 5.\r\n */\r\nclass BrowserSupports\r\n{\r\n   /**\r\n    * Check for container query support.\r\n    *\r\n    * @returns {boolean} True if container queries supported.\r\n    */\r\n   static get containerQueries()\r\n   {\r\n      return 'container' in document.documentElement.style;\r\n   }\r\n}\n\n/**\r\n * Provides access to the Clipboard API for reading / writing text strings. This requires a secure context.\r\n *\r\n * Note: `writeText` will attempt to use the older `execCommand` if available when `navigator.clipboard` is not\r\n * available.\r\n */\r\nclass ClipboardAccess\r\n{\r\n   /**\r\n    * Uses `navigator.clipboard` if available to read text from the clipboard.\r\n    *\r\n    * Note: Always returns `undefined` when `navigator.clipboard` is not available or the clipboard contains the\r\n    * empty string.\r\n    *\r\n    * @returns {Promise<string|undefined>} The current clipboard text or undefined.\r\n    */\r\n   static async readText()\r\n   {\r\n      let result;\r\n\r\n      if (globalThis?.navigator?.clipboard)\r\n      {\r\n         try\r\n         {\r\n            result = await globalThis.navigator.clipboard.readText();\r\n         }\r\n         catch (err) { /**/ }\r\n      }\r\n\r\n      return result === '' ? void 0 : result;\r\n   }\r\n\r\n   /**\r\n    * Uses `navigator.clipboard` if available then falls back to `document.execCommand('copy')` if available to copy\r\n    * the given text to the clipboard.\r\n    *\r\n    * @param {string}   text - Text to copy to the browser clipboard.\r\n    *\r\n    * @returns {Promise<boolean>} Copy successful.\r\n    */\r\n   static async writeText(text)\r\n   {\r\n      if (typeof text !== 'string')\r\n      {\r\n         throw new TypeError(`ClipboardAccess.writeText error: 'text' is not a string.`);\r\n      }\r\n\r\n      let success = false;\r\n\r\n      if (globalThis?.navigator?.clipboard)\r\n      {\r\n         try\r\n         {\r\n            await globalThis.navigator.clipboard.writeText(text);\r\n            success = true;\r\n         }\r\n         catch (err) { /**/ }\r\n      }\r\n      else if (globalThis?.document?.execCommand instanceof Function)\r\n      {\r\n         const textArea = globalThis.document.createElement('textarea');\r\n\r\n         // Place in the top-left corner of screen regardless of scroll position.\r\n         textArea.style.position = 'fixed';\r\n         textArea.style.top = '0';\r\n         textArea.style.left = '0';\r\n\r\n         // Ensure it has a small width and height. Setting to 1px / 1em\r\n         // doesn't work as this gives a negative w/h on some browsers.\r\n         textArea.style.width = '2em';\r\n         textArea.style.height = '2em';\r\n\r\n         // We don't need padding, reducing the size if it does flash render.\r\n         textArea.style.padding = '0';\r\n\r\n         // Clean up any borders.\r\n         textArea.style.border = 'none';\r\n         textArea.style.outline = 'none';\r\n         textArea.style.boxShadow = 'none';\r\n\r\n         // Avoid flash of the white box if rendered for any reason.\r\n         textArea.style.background = 'transparent';\r\n\r\n         textArea.value = text;\r\n\r\n         globalThis.document.body.appendChild(textArea);\r\n         textArea.focus();\r\n         textArea.select();\r\n\r\n         try\r\n         {\r\n            success = document.execCommand('copy');\r\n         }\r\n         catch (err) { /**/ }\r\n\r\n         document.body.removeChild(textArea);\r\n      }\r\n\r\n      return success;\r\n   }\r\n}\n\n/**\r\n * Provides a solid string hashing algorithm.\r\n *\r\n * Sourced from: https://stackoverflow.com/a/52171480\r\n *\r\n * @param {string}   str - String to hash.\r\n *\r\n * @param {number}   seed - A seed value altering the hash.\r\n *\r\n * @returns {number} Hash code.\r\n */\r\nfunction hashCode(str, seed = 0)\r\n{\r\n   if (typeof str !== 'string') { return 0; }\r\n\r\n   let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\r\n\r\n   for (let ch, i = 0; i < str.length; i++)\r\n   {\r\n      ch = str.charCodeAt(i);\r\n      h1 = Math.imul(h1 ^ ch, 2654435761);\r\n      h2 = Math.imul(h2 ^ ch, 1597334677);\r\n   }\r\n\r\n   h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);\r\n   h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);\r\n\r\n   return 4294967296 * (2097151 & h2) + (h1 >>> 0);\r\n}\n\nconst s_UUIDV4_REGEX = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;\r\n\r\n/**\r\n * Generates a UUID v4 compliant ID. Please use a complete UUID generation package for guaranteed compliance.\r\n *\r\n * This code is an evolution of the following Gist.\r\n * https://gist.github.com/jed/982883\r\n *\r\n * There is a public domain / free copy license attached to it that is not a standard OSS license...\r\n * https://gist.github.com/jed/982883#file-license-txt\r\n *\r\n * @returns {string} UUIDv4\r\n */\r\nfunction uuidv4()\r\n{\r\n   return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) =>\r\n    (c ^ (globalThis.crypto || globalThis.msCrypto).getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));\r\n}\r\n\r\n/**\r\n * Validates that the given string is formatted as a UUIDv4 string.\r\n *\r\n * @param {string}   uuid - UUID string to test.\r\n *\r\n * @returns {boolean} Is UUIDv4 string.\r\n */\r\nuuidv4.isValid = (uuid) => s_UUIDV4_REGEX.test(uuid);\n\n/**\r\n * Normalizes a string.\r\n *\r\n * @param {string}   query - A string to normalize for comparisons.\r\n *\r\n * @returns {string} Cleaned string.\r\n *\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize\r\n */\r\nfunction normalizeString(query)\r\n{\r\n   return query.trim().normalize('NFD').replace(/[\\x00-\\x1F]/gm, ''); // eslint-disable-line no-control-regex\r\n}\n\n/**\r\n * Recursive function that finds the closest parent stacking context.\r\n * See also https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\r\n *\r\n * Original author: Kerry Liu / https://github.com/gwwar\r\n *\r\n * @see https://github.com/gwwar/z-context/blob/master/content-script.js\r\n * @see https://github.com/gwwar/z-context/blob/master/LICENSE\r\n *\r\n * @param {Element} node -\r\n *\r\n * @returns {StackingContext} The closest parent stacking context\r\n */\r\nfunction getStackingContext(node)\r\n{\r\n   // the root element (HTML).\r\n   if (!node || node.nodeName === 'HTML')\r\n   {\r\n      return { node: document.documentElement, reason: 'root' };\r\n   }\r\n\r\n   // handle shadow root elements.\r\n   if (node.nodeName === '#document-fragment')\r\n   {\r\n      return getStackingContext(node.host);\r\n   }\r\n\r\n   const computedStyle = globalThis.getComputedStyle(node);\r\n\r\n   // position: fixed or sticky.\r\n   if (computedStyle.position === 'fixed' || computedStyle.position === 'sticky')\r\n   {\r\n      return { node, reason: `position: ${computedStyle.position}` };\r\n   }\r\n\r\n   // positioned (absolutely or relatively) with a z-index value other than \"auto\".\r\n   if (computedStyle.zIndex !== 'auto' && computedStyle.position !== 'static')\r\n   {\r\n      return { node, reason: `position: ${computedStyle.position}; z-index: ${computedStyle.zIndex}` };\r\n   }\r\n\r\n   // elements with an opacity value less than 1.\r\n   if (computedStyle.opacity !== '1')\r\n   {\r\n      return { node, reason: `opacity: ${computedStyle.opacity}` };\r\n   }\r\n\r\n   // elements with a transform value other than \"none\".\r\n   if (computedStyle.transform !== 'none')\r\n   {\r\n      return { node, reason: `transform: ${computedStyle.transform}` };\r\n   }\r\n\r\n   // elements with a mix-blend-mode value other than \"normal\".\r\n   if (computedStyle.mixBlendMode !== 'normal')\r\n   {\r\n      return { node, reason: `mixBlendMode: ${computedStyle.mixBlendMode}` };\r\n   }\r\n\r\n   // elements with a filter value other than \"none\".\r\n   if (computedStyle.filter !== 'none')\r\n   {\r\n      return { node, reason: `filter: ${computedStyle.filter}` };\r\n   }\r\n\r\n   // elements with a perspective value other than \"none\".\r\n   if (computedStyle.perspective !== 'none')\r\n   {\r\n      return { node, reason: `perspective: ${computedStyle.perspective}` };\r\n   }\r\n\r\n   // elements with a clip-path value other than \"none\".\r\n   if (computedStyle.clipPath !== 'none')\r\n   {\r\n      return { node, reason: `clip-path: ${computedStyle.clipPath} ` };\r\n   }\r\n\r\n   // elements with a mask value other than \"none\".\r\n   const mask = computedStyle.mask || computedStyle.webkitMask;\r\n   if (mask !== 'none' && mask !== undefined)\r\n   {\r\n      return { node, reason: `mask:  ${mask}` };\r\n   }\r\n\r\n   // elements with a mask-image value other than \"none\".\r\n   const maskImage = computedStyle.maskImage || computedStyle.webkitMaskImage;\r\n   if (maskImage !== 'none' && maskImage !== undefined)\r\n   {\r\n      return { node, reason: `mask-image: ${maskImage}` };\r\n   }\r\n\r\n   // elements with a mask-border value other than \"none\".\r\n   const maskBorder = computedStyle.maskBorder || computedStyle.webkitMaskBorder;\r\n   if (maskBorder !== 'none' && maskBorder !== undefined)\r\n   {\r\n      return { node, reason: `mask-border: ${maskBorder}` };\r\n   }\r\n\r\n   // elements with isolation set to \"isolate\".\r\n   if (computedStyle.isolation === 'isolate')\r\n   {\r\n      return { node, reason: `isolation: ${computedStyle.isolation}` };\r\n   }\r\n\r\n   // transform or opacity in will-change even if you don't specify values for these attributes directly.\r\n   if (computedStyle.willChange === 'transform' || computedStyle.willChange === 'opacity')\r\n   {\r\n      return { node, reason: `willChange: ${computedStyle.willChange}` };\r\n   }\r\n\r\n   // elements with -webkit-overflow-scrolling set to \"touch\".\r\n   if (computedStyle.webkitOverflowScrolling === 'touch')\r\n   {\r\n      return { node, reason: '-webkit-overflow-scrolling: touch' };\r\n   }\r\n\r\n   // an item with a z-index value other than \"auto\".\r\n   if (computedStyle.zIndex !== 'auto')\r\n   {\r\n      const parentStyle = globalThis.getComputedStyle(node.parentNode);\r\n      // with a flex|inline-flex parent.\r\n      if (parentStyle.display === 'flex' || parentStyle.display === 'inline-flex')\r\n      {\r\n         return { node, reason: `flex-item; z-index: ${computedStyle.zIndex}` };\r\n         // with a grid parent.\r\n      }\r\n      else if (parentStyle.grid !== 'none / none / none / row / auto / auto')\r\n      {\r\n         return { node, reason: `child of grid container; z-index: ${computedStyle.zIndex}` };\r\n      }\r\n   }\r\n\r\n   // contain with a value of layout, or paint, or a composite value that includes either of them\r\n   const contain = computedStyle.contain;\r\n   if (['layout', 'paint', 'strict', 'content'].indexOf(contain) > -1 ||\r\n    contain.indexOf('paint') > -1 ||\r\n    contain.indexOf('layout') > -1\r\n   )\r\n   {\r\n      return { node, reason: `contain: ${contain}` };\r\n   }\r\n\r\n   return getStackingContext(node.parentNode);\r\n}\r\n\r\n/**\r\n * @typedef {object} StackingContext\r\n *\r\n * @property {Element} node - A DOM Element.\r\n *\r\n * @property {string}  reason - Reason for why a stacking context was created.\r\n */\n\nconst s_REGEX = /(\\d+)\\s*px/;\r\n\r\n/**\r\n * Parses a pixel string / computed styles. Ex. `100px` returns `100`.\r\n *\r\n * @param {string}   value - Value to parse.\r\n *\r\n * @returns {number|undefined} The integer component of a pixel string.\r\n */\r\nfunction styleParsePixels(value)\r\n{\r\n   if (typeof value !== 'string') { return void 0; }\r\n\r\n   const isPixels = s_REGEX.test(value);\r\n   const number = parseInt(value);\r\n\r\n   return isPixels && Number.isFinite(number) ? number : void 0;\r\n}\n\n/**\r\n * Provides a managed dynamic style sheet / element useful in configuring global CSS variables. When creating an\r\n * instance of TJSStyleManager you must provide a \"document key\" / string for the style element added. The style element\r\n * can be accessed via `document[docKey]`.\r\n *\r\n * Instances of TJSStyleManager can also be versioned by supplying a positive integer greater than or equal to `1` via\r\n * the 'version' option. This version number is assigned to the associated style element. When a TJSStyleManager\r\n * instance is created and there is an existing instance with a version that is lower than the current instance all CSS\r\n * rules are removed letting the higher version to take precedence. This isn't a perfect system and requires thoughtful\r\n * construction of CSS variables exposed, but allows multiple independently compiled TRL packages to load the latest\r\n * CSS variables. It is recommended to always set `overwrite` option of {@link TJSStyleManager.setProperty} and\r\n * {@link TJSStyleManager.setProperties} to `false` when loading initial values.\r\n */\r\nclass TJSStyleManager\r\n{\r\n   /** @type {CSSStyleRule} */\r\n   #cssRule;\r\n\r\n   /** @type {string} */\r\n   #docKey;\r\n\r\n   /** @type {string} */\r\n   #selector;\r\n\r\n   /** @type {HTMLStyleElement} */\r\n   #styleElement;\r\n\r\n   /** @type {number} */\r\n   #version;\r\n\r\n   /**\r\n    *\r\n    * @param {object}   opts - Options.\r\n    *\r\n    * @param {string}   opts.docKey - Required key providing a link to a specific style sheet element.\r\n    *\r\n    * @param {string}   [opts.selector=:root] - Selector element.\r\n    *\r\n    * @param {Document} [opts.document] - Target document to load styles into.\r\n    *\r\n    * @param {number}   [opts.version] - An integer representing the version / level of styles being managed.\r\n    */\r\n   constructor({ docKey, selector = ':root', document = globalThis.document, version } = {})\r\n   {\r\n      if (typeof docKey !== 'string') { throw new TypeError(`StyleManager error: 'docKey' is not a string.`); }\r\n\r\n      // TODO: Verify 'document' type from Popout FVTT module. For some reason the popout document trips this\r\n      //  unintentionally.\r\n      // if (!(document instanceof Document))\r\n      // {\r\n      //    throw new TypeError(`TJSStyleManager error: 'document' is not an instance of Document.`);\r\n      // }\r\n\r\n      if (typeof selector !== 'string') { throw new TypeError(`StyleManager error: 'selector' is not a string.`); }\r\n\r\n      if (version !== void 0 && !Number.isSafeInteger(version) && version < 1)\r\n      {\r\n         throw new TypeError(`StyleManager error: 'version' is defined and is not a positive integer >= 1.`);\r\n      }\r\n\r\n      this.#selector = selector;\r\n      this.#docKey = docKey;\r\n      this.#version = version;\r\n\r\n      if (document[this.#docKey] === void 0)\r\n      {\r\n         this.#styleElement = document.createElement('style');\r\n\r\n         document.head.append(this.#styleElement);\r\n\r\n         // Set initial style manager version if any supplied.\r\n         this.#styleElement._STYLE_MANAGER_VERSION = version;\r\n\r\n         this.#styleElement.sheet.insertRule(`${selector} {}`, 0);\r\n\r\n         this.#cssRule = this.#styleElement.sheet.cssRules[0];\r\n\r\n         document[docKey] = this.#styleElement;\r\n      }\r\n      else\r\n      {\r\n         this.#styleElement = document[docKey];\r\n         this.#cssRule = this.#styleElement.sheet.cssRules[0];\r\n\r\n         if (version)\r\n         {\r\n            const existingVersion = this.#styleElement._STYLE_MANAGER_VERSION ?? 0;\r\n\r\n            // Remove all existing CSS rules / text if version is greater than existing version.\r\n            if (version > existingVersion)\r\n            {\r\n               this.#cssRule.style.cssText = '';\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * @returns {string} Provides an accessor to get the `cssText` for the style sheet.\r\n    */\r\n   get cssText()\r\n   {\r\n      return this.#cssRule.style.cssText;\r\n   }\r\n\r\n   /**\r\n    * @returns {number} Returns the version of this instance.\r\n    */\r\n   get version()\r\n   {\r\n      return this.#version;\r\n   }\r\n\r\n   /**\r\n    * Provides a copy constructor to duplicate an existing TJSStyleManager instance into a new document.\r\n    *\r\n    * Note: This is used to support the `PopOut` module.\r\n    *\r\n    * @param {Document} [document] Target browser document to clone into.\r\n    *\r\n    * @returns {TJSStyleManager} New style manager instance.\r\n    */\r\n   clone(document = globalThis.document)\r\n   {\r\n      const newStyleManager = new TJSStyleManager({\r\n         selector: this.#selector,\r\n         docKey: this.#docKey,\r\n         document,\r\n         version: this.#version\r\n      });\r\n\r\n      newStyleManager.#cssRule.style.cssText = this.#cssRule.style.cssText;\r\n\r\n      return newStyleManager;\r\n   }\r\n\r\n   get()\r\n   {\r\n      const cssText = this.#cssRule.style.cssText;\r\n\r\n      const result = {};\r\n\r\n      if (cssText !== '')\r\n      {\r\n         for (const entry of cssText.split(';'))\r\n         {\r\n            if (entry !== '')\r\n            {\r\n               const values = entry.split(':');\r\n               result[values[0].trim()] = values[1];\r\n            }\r\n         }\r\n      }\r\n\r\n      return result;\r\n   }\r\n\r\n   /**\r\n    * Gets a particular CSS variable.\r\n    *\r\n    * @param {string}   key - CSS variable property key.\r\n    *\r\n    * @returns {string} Returns CSS variable value.\r\n    */\r\n   getProperty(key)\r\n   {\r\n      if (typeof key !== 'string') { throw new TypeError(`StyleManager error: 'key' is not a string.`); }\r\n\r\n      return this.#cssRule.style.getPropertyValue(key);\r\n   }\r\n\r\n   /**\r\n    * Set rules by property / value; useful for CSS variables.\r\n    *\r\n    * @param {{ [key: string]: string }}  rules - An object with property / value string pairs to load.\r\n    *\r\n    * @param {boolean}                 [overwrite=true] - When true overwrites any existing values.\r\n    */\r\n   setProperties(rules, overwrite = true)\r\n   {\r\n      if (!isObject(rules)) { throw new TypeError(`StyleManager error: 'rules' is not an object.`); }\r\n\r\n      if (typeof overwrite !== 'boolean') { throw new TypeError(`StyleManager error: 'overwrite' is not a boolean.`); }\r\n\r\n      if (overwrite)\r\n      {\r\n         for (const [key, value] of Object.entries(rules))\r\n         {\r\n            this.#cssRule.style.setProperty(key, value);\r\n         }\r\n      }\r\n      else\r\n      {\r\n         // Only set property keys for entries that don't have an existing rule set.\r\n         for (const [key, value] of Object.entries(rules))\r\n         {\r\n            if (this.#cssRule.style.getPropertyValue(key) === '')\r\n            {\r\n               this.#cssRule.style.setProperty(key, value);\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Sets a particular property.\r\n    *\r\n    * @param {string}   key - CSS variable property key.\r\n    *\r\n    * @param {string}   value - CSS variable value.\r\n    *\r\n    * @param {boolean}  [overwrite=true] - Overwrite any existing value.\r\n    */\r\n   setProperty(key, value, overwrite = true)\r\n   {\r\n      if (typeof key !== 'string') { throw new TypeError(`StyleManager error: 'key' is not a string.`); }\r\n\r\n      if (typeof value !== 'string') { throw new TypeError(`StyleManager error: 'value' is not a string.`); }\r\n\r\n      if (typeof overwrite !== 'boolean') { throw new TypeError(`StyleManager error: 'overwrite' is not a boolean.`); }\r\n\r\n      if (overwrite)\r\n      {\r\n         this.#cssRule.style.setProperty(key, value);\r\n      }\r\n      else\r\n      {\r\n         if (this.#cssRule.style.getPropertyValue(key) === '')\r\n         {\r\n            this.#cssRule.style.setProperty(key, value);\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Removes the property keys specified. If `keys` is an iterable list then all property keys in the list are removed.\r\n    *\r\n    * @param {Iterable<string>} keys - The property keys to remove.\r\n    */\r\n   removeProperties(keys)\r\n   {\r\n      if (!isIterable(keys)) { throw new TypeError(`StyleManager error: 'keys' is not an iterable list.`); }\r\n\r\n      for (const key of keys)\r\n      {\r\n         if (typeof key === 'string') { this.#cssRule.style.removeProperty(key); }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Removes a particular CSS variable.\r\n    *\r\n    * @param {string}   key - CSS variable property key.\r\n    *\r\n    * @returns {string} CSS variable value when removed.\r\n    */\r\n   removeProperty(key)\r\n   {\r\n      if (typeof key !== 'string') { throw new TypeError(`StyleManager error: 'key' is not a string.`); }\r\n\r\n      return this.#cssRule.style.removeProperty(key);\r\n   }\r\n}\n\n/**\r\n * Defines the application shell contract. If Svelte components export getter / setters for the following properties\r\n * then that component is considered an application shell.\r\n *\r\n * @type {string[]}\r\n */\r\nconst applicationShellContract = ['elementRoot'];\r\n\r\nObject.freeze(applicationShellContract);\n\n/**\r\n * Provides a method to determine if the passed in object / Svelte component follows the application shell contract.\r\n * This involves ensuring that the accessors defined in `applicationShellContract`.\r\n *\r\n * Note: A caveat is that when using Vite in a developer build components are wrapped in a proxy / ProxyComponent that\r\n * defines instance accessors versus on the prototype, so the check below ensures that all accessors in the contract are\r\n * either available on the prototype or directly on the instance.\r\n *\r\n * @param {*}  component - Object / component to test.\r\n *\r\n * @returns {boolean} Whether the component is a ApplicationShell or TJSApplicationShell.\r\n */\r\nfunction isApplicationShell(component)\r\n{\r\n   if (component === null || component === void 0) { return false; }\r\n\r\n   let compHasContract = true;\r\n   let protoHasContract = true;\r\n\r\n   // Check for accessors on the instance.\r\n   for (const accessor of applicationShellContract)\r\n   {\r\n      const descriptor = Object.getOwnPropertyDescriptor(component, accessor);\r\n      if (descriptor === void 0 || descriptor.get === void 0 || descriptor.set === void 0) { compHasContract = false; }\r\n   }\r\n\r\n   // Get the prototype which is the parent SvelteComponent that has any getter / setters.\r\n   const prototype = Object.getPrototypeOf(component);\r\n\r\n   // Verify the application shell contract. If the accessors (getters / setters) are defined for\r\n   // `applicationShellContract`.\r\n   for (const accessor of applicationShellContract)\r\n   {\r\n      const descriptor = Object.getOwnPropertyDescriptor(prototype, accessor);\r\n      if (descriptor === void 0 || descriptor.get === void 0 || descriptor.set === void 0) { protoHasContract = false; }\r\n   }\r\n\r\n   return compHasContract || protoHasContract;\r\n}\n\n/**\r\n * Provides basic duck typing to determine if the provided object is a HMR ProxyComponent instance or class.\r\n *\r\n * @param {*}  comp - Data to check as a HMR proxy component.\r\n *\r\n * @returns {boolean} Whether basic duck typing succeeds.\r\n */\r\nfunction isHMRProxy(comp)\r\n{\r\n   const instanceName = comp?.constructor?.name;\r\n   if (typeof instanceName === 'string' && (instanceName.startsWith('Proxy<') || instanceName === 'ProxyComponent'))\r\n   {\r\n      return true;\r\n   }\r\n\r\n   const prototypeName = comp?.prototype?.constructor?.name;\r\n   return typeof prototypeName === 'string' && (prototypeName.startsWith('Proxy<') ||\r\n    prototypeName === 'ProxyComponent');\r\n}\n\n/**\r\n * Provides basic duck typing to determine if the provided function is a constructor function for a Svelte component.\r\n *\r\n * @param {*}  comp - Data to check as a Svelte component.\r\n *\r\n * @returns {boolean} Whether basic duck typing succeeds.\r\n */\r\nfunction isSvelteComponent(comp)\r\n{\r\n   if (comp === null || comp === void 0 || typeof comp !== 'function') { return false; }\r\n\r\n   // When using Vite in a developer build the SvelteComponent is wrapped in a ProxyComponent class.\r\n   // This class doesn't define methods on the prototype, so we must check if the constructor name\r\n   // starts with `Proxy<` as it provides the wrapped component as `Proxy<_wrapped component name_>`.\r\n   const prototypeName = comp?.prototype?.constructor?.name;\r\n   if (typeof prototypeName === 'string' && (prototypeName.startsWith('Proxy<') || prototypeName === 'ProxyComponent'))\r\n   {\r\n      return true;\r\n   }\r\n\r\n   return typeof window !== void 0 ?\r\n    typeof comp.prototype.$destroy === 'function' && typeof comp.prototype.$on === 'function' : // client-side\r\n     typeof comp.render === 'function'; // server-side\r\n}\n\n/**\r\n * Validates `config` argument whether it is a valid {@link TJSSvelteConfig}.\r\n *\r\n * @param {*}  config - The potential config object to validate.\r\n *\r\n * @param {boolean}  [raiseException=false] - If validation fails raise an exception.\r\n *\r\n * @returns {boolean} Is the config a valid TJSSvelteConfig.\r\n *\r\n * @throws {TypeError}  Any validation error when `raiseException` is enabled.\r\n */\r\nfunction isTJSSvelteConfig(config, raiseException = false)\r\n{\r\n   if (!isObject(config))\r\n   {\r\n      if (raiseException) { throw new TypeError(`isTJSSvelteConfig error: 'config' is not an object.`); }\r\n      return false;\r\n   }\r\n\r\n   if (!isSvelteComponent(config.class))\r\n   {\r\n      if (raiseException)\r\n      {\r\n         throw new TypeError(`isTJSSvelteConfig error: 'config.class' is not a Svelte component constructor.`);\r\n      }\r\n      return false;\r\n   }\r\n\r\n   return true;\r\n}\r\n\r\n/* eslint-disable */  // jsdoc/valid-types doesn't like the Google closure constructor function. TODO: verify in future eslint-plugin-jsdoc version\r\n/**\r\n * @typedef {object} TJSSvelteConfig\r\n *\r\n * @property {{ new(options: import('#svelte').ComponentConstructorOptions): import('#svelte').SvelteComponent | import('#svelte').SvelteComponentTyped }} class -\r\n *\r\n * @property {Element|Document|ShadowRoot}   [target=document.body] -\r\n *\r\n * @property {Element} [anchor] -\r\n *\r\n * @property {() => Record<string, *> | Record<string, *>} [props] -\r\n *\r\n * @property {() => (Record<string, *> | Map<string, *>) | Map<string, *> | Record<string, *>} [context] -\r\n *\r\n * @property {boolean}  [hydrate] -\r\n *\r\n * @property {boolean} [intro] -\r\n *\r\n * @property {boolean}  [$$inline] -\r\n */\r\n/* eslint-enable */\n\n/**\r\n * Runs outro transition then destroys Svelte component.\r\n *\r\n * Workaround for https://github.com/sveltejs/svelte/issues/4056\r\n *\r\n * @param {*}  instance - A Svelte component.\r\n */\r\nasync function outroAndDestroy(instance)\r\n{\r\n   return new Promise((resolve) =>\r\n   {\r\n      if (instance.$$.fragment && instance.$$.fragment.o)\r\n      {\r\n         group_outros();\r\n         transition_out(instance.$$.fragment, 0, 0, () =>\r\n         {\r\n            instance.$destroy();\r\n            resolve();\r\n         });\r\n         check_outros();\r\n      }\r\n      else\r\n      {\r\n         instance.$destroy();\r\n         resolve();\r\n      }\r\n   });\r\n}\n\n/**\r\n * Parses a TyphonJS Svelte config object ensuring that classes specified are Svelte components and props are set\r\n * correctly.\r\n *\r\n * @param {object}   config - Svelte config object.\r\n *\r\n * @param {*}        [thisArg] - `This` reference to set for invoking any props function.\r\n *\r\n * @returns {object} The processed Svelte config object.\r\n */\r\nfunction parseTJSSvelteConfig(config, thisArg = void 0)\r\n{\r\n   if (typeof config !== 'object')\r\n   {\r\n      throw new TypeError(`parseSvelteConfig - 'config' is not an object:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   if (!isSvelteComponent(config.class))\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'class' is not a Svelte component constructor for config:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   if (config.hydrate !== void 0 && typeof config.hydrate !== 'boolean')\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'hydrate' is not a boolean for config:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   if (config.intro !== void 0 && typeof config.intro !== 'boolean')\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'intro' is not a boolean for config:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   if (config.target !== void 0 && typeof config.target !== 'string' && !(config.target instanceof HTMLElement) &&\r\n    !(config.target instanceof ShadowRoot) && !(config.target instanceof DocumentFragment))\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'target' is not a string, HTMLElement, ShadowRoot, or DocumentFragment for config:\\n${\r\n        JSON.stringify(config)}.`);\r\n   }\r\n\r\n   if (config.anchor !== void 0 && typeof config.anchor !== 'string' && !(config.anchor instanceof HTMLElement) &&\r\n    !(config.anchor instanceof ShadowRoot) && !(config.anchor instanceof DocumentFragment))\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'anchor' is not a string, HTMLElement, ShadowRoot, or DocumentFragment for config:\\n${\r\n        JSON.stringify(config)}.`);\r\n   }\r\n\r\n   if (config.context !== void 0 && typeof config.context !== 'function' && !(config.context instanceof Map) &&\r\n    typeof config.context !== 'object')\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'context' is not a Map, function or object for config:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   // Validate extra TyphonJS options --------------------------------------------------------------------------------\r\n\r\n   // `selectorTarget` optionally stores a target element found in main element.\r\n   if (config.selectorTarget !== void 0 && typeof config.selectorTarget !== 'string')\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'selectorTarget' is not a string for config:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   // `options` stores `injectApp`, `injectEventbus`, and `selectorElement`.\r\n   if (config.options !== void 0 && typeof config.options !== 'object')\r\n   {\r\n      throw new TypeError(\r\n       `parseSvelteConfig - 'options' is not an object for config:\\n${JSON.stringify(config)}.`);\r\n   }\r\n\r\n   // Validate TyphonJS standard options.\r\n   if (config.options !== void 0)\r\n   {\r\n      if (config.options.injectApp !== void 0 && typeof config.options.injectApp !== 'boolean')\r\n      {\r\n         throw new TypeError(\r\n          `parseSvelteConfig - 'options.injectApp' is not a boolean for config:\\n${JSON.stringify(config)}.`);\r\n      }\r\n\r\n      if (config.options.injectEventbus !== void 0 && typeof config.options.injectEventbus !== 'boolean')\r\n      {\r\n         throw new TypeError(\r\n          `parseSvelteConfig - 'options.injectEventbus' is not a boolean for config:\\n${JSON.stringify(config)}.`);\r\n      }\r\n\r\n      // `selectorElement` optionally stores a main element selector to be found in a HTMLElement target.\r\n      if (config.options.selectorElement !== void 0 && typeof config.options.selectorElement !== 'string')\r\n      {\r\n         throw new TypeError(\r\n          `parseSvelteConfig - 'selectorElement' is not a string for config:\\n${JSON.stringify(config)}.`);\r\n      }\r\n   }\r\n\r\n   const svelteConfig = { ...config };\r\n\r\n   // Delete extra Svelte options.\r\n   delete svelteConfig.options;\r\n\r\n   let externalContext = {};\r\n\r\n   // If a context callback function is provided then invoke it with `this` being the Foundry app.\r\n   // If an object is returned it adds the entries to external context.\r\n   if (typeof svelteConfig.context === 'function')\r\n   {\r\n      const contextFunc = svelteConfig.context;\r\n      delete svelteConfig.context;\r\n\r\n      const result = contextFunc.call(thisArg);\r\n      if (isObject(result))\r\n      {\r\n         externalContext = { ...result };\r\n      }\r\n      else\r\n      {\r\n         throw new Error(`parseSvelteConfig - 'context' is a function that did not return an object for config:\\n${\r\n          JSON.stringify(config)}`);\r\n      }\r\n   }\r\n   else if (svelteConfig.context instanceof Map)\r\n   {\r\n      externalContext = Object.fromEntries(svelteConfig.context);\r\n      delete svelteConfig.context;\r\n   }\r\n   else if (isObject(svelteConfig.context))\r\n   {\r\n      externalContext = svelteConfig.context;\r\n      delete svelteConfig.context;\r\n   }\r\n\r\n   // If a props is a function then invoke it with `this` being the Foundry app.\r\n   // If an object is returned set it as the props.\r\n   svelteConfig.props = s_PROCESS_PROPS(svelteConfig.props, thisArg, config);\r\n\r\n   // Process children components attaching to external context.\r\n   if (Array.isArray(svelteConfig.children))\r\n   {\r\n      const children = [];\r\n\r\n      for (let cntr = 0; cntr < svelteConfig.children.length; cntr++)\r\n      {\r\n         const child = svelteConfig.children[cntr];\r\n\r\n         if (!isSvelteComponent(child.class))\r\n         {\r\n            throw new Error(`parseSvelteConfig - 'class' is not a Svelte component for child[${cntr}] for config:\\n${\r\n             JSON.stringify(config)}`);\r\n         }\r\n\r\n         child.props = s_PROCESS_PROPS(child.props, thisArg, config);\r\n\r\n         children.push(child);\r\n      }\r\n\r\n      if (children.length > 0)\r\n      {\r\n         externalContext.children = children;\r\n      }\r\n\r\n      delete svelteConfig.children;\r\n   }\r\n   else if (isObject(svelteConfig.children))\r\n   {\r\n      if (!isSvelteComponent(svelteConfig.children.class))\r\n      {\r\n         throw new Error(`parseSvelteConfig - 'class' is not a Svelte component for children object for config:\\n${\r\n          JSON.stringify(config)}`);\r\n      }\r\n\r\n      svelteConfig.children.props = s_PROCESS_PROPS(svelteConfig.children.props, thisArg, config);\r\n\r\n      externalContext.children = [svelteConfig.children];\r\n      delete svelteConfig.children;\r\n   }\r\n\r\n   if (!(svelteConfig.context instanceof Map))\r\n   {\r\n      svelteConfig.context = new Map();\r\n   }\r\n\r\n   svelteConfig.context.set('#external', externalContext);\r\n\r\n   return svelteConfig;\r\n}\r\n\r\n/**\r\n * Processes Svelte props. Potentially props can be a function to invoke with `thisArg`.\r\n *\r\n * @param {object|Function}   props - Svelte props.\r\n *\r\n * @param {*}                 thisArg - `This` reference to set for invoking any props function.\r\n *\r\n * @param {object}            config - Svelte config\r\n *\r\n * @returns {object|void}     Svelte props.\r\n */\r\nfunction s_PROCESS_PROPS(props, thisArg, config)\r\n{\r\n   // If a props is a function then invoke it with `this` being the Foundry app.\r\n   // If an object is returned set it as the props.\r\n   if (typeof props === 'function')\r\n   {\r\n      const result = props.call(thisArg);\r\n      if (isObject(result))\r\n      {\r\n         return result;\r\n      }\r\n      else\r\n      {\r\n         throw new Error(`parseSvelteConfig - 'props' is a function that did not return an object for config:\\n${\r\n          JSON.stringify(config)}`);\r\n      }\r\n   }\r\n   else if (isObject(props))\r\n   {\r\n      return props;\r\n   }\r\n   else if (props !== void 0)\r\n   {\r\n      throw new Error(\r\n       `parseSvelteConfig - 'props' is not a function or an object for config:\\n${JSON.stringify(config)}`);\r\n   }\r\n\r\n   return {};\r\n}\n\n/**\r\n * Wraps a callback in a debounced timeout.\r\n *\r\n * Delay execution of the callback function until the function has not been called for the given delay in milliseconds.\r\n *\r\n * @param {Function} callback - A function to execute once the debounced threshold has been passed.\r\n *\r\n * @param {number}   delay - An amount of time in milliseconds to delay.\r\n *\r\n * @returns {Function} A wrapped function that can be called to debounce execution.\r\n */\r\nfunction debounce(callback, delay)\r\n{\r\n   let timeoutId;\r\n\r\n   return function(...args)\r\n   {\r\n      clearTimeout(timeoutId);\r\n      timeoutId = setTimeout(() => { callback.apply(this, args); }, delay);\r\n   };\r\n}\n\n/**\r\n * Provides a method to determine if the passed in Svelte component has a getter accessor.\r\n *\r\n * @param {*}        object - An object.\r\n *\r\n * @param {string}   accessor - Accessor to test.\r\n *\r\n * @returns {boolean} Whether the component has the getter for accessor.\r\n */\r\nfunction hasGetter(object, accessor)\r\n{\r\n   if (object === null || object === void 0) { return false; }\r\n\r\n   // Check for instance accessor.\r\n   const iDescriptor = Object.getOwnPropertyDescriptor(object, accessor);\r\n   if (iDescriptor !== void 0 && iDescriptor.get !== void 0) { return true; }\r\n\r\n   // Walk parent prototype chain. Check for descriptor at each prototype level.\r\n   for (let o = Object.getPrototypeOf(object); o; o = Object.getPrototypeOf(o))\r\n   {\r\n      const descriptor = Object.getOwnPropertyDescriptor(o, accessor);\r\n      if (descriptor !== void 0 && descriptor.get !== void 0) { return true; }\r\n   }\r\n\r\n   return false;\r\n}\r\n\r\n/**\r\n * Provides a method to determine if the passed in Svelte component has a getter & setter accessor.\r\n *\r\n * @param {*}        object - An object.\r\n *\r\n * @param {string}   accessor - Accessor to test.\r\n *\r\n * @returns {boolean} Whether the component has the getter and setter for accessor.\r\n */\r\nfunction hasAccessor(object, accessor)\r\n{\r\n   if (object === null || object === void 0) { return false; }\r\n\r\n   // Check for instance accessor.\r\n   const iDescriptor = Object.getOwnPropertyDescriptor(object, accessor);\r\n   if (iDescriptor !== void 0 && iDescriptor.get !== void 0 && iDescriptor.set !== void 0) { return true; }\r\n\r\n   // Walk parent prototype chain. Check for descriptor at each prototype level.\r\n   for (let o = Object.getPrototypeOf(object); o; o = Object.getPrototypeOf(o))\r\n   {\r\n      const descriptor = Object.getOwnPropertyDescriptor(o, accessor);\r\n      if (descriptor !== void 0 && descriptor.get !== void 0 && descriptor.set !== void 0) { return true; }\r\n   }\r\n\r\n   return false;\r\n}\r\n\r\n/**\r\n * Provides a method to determine if the passed in Svelte component has a setter accessor.\r\n *\r\n * @param {*}        object - An object.\r\n *\r\n * @param {string}   accessor - Accessor to test.\r\n *\r\n * @returns {boolean} Whether the component has the setter for accessor.\r\n */\r\nfunction hasSetter(object, accessor)\r\n{\r\n   if (object === null || object === void 0) { return false; }\r\n\r\n   // Check for instance accessor.\r\n   const iDescriptor = Object.getOwnPropertyDescriptor(object, accessor);\r\n   if (iDescriptor !== void 0 && iDescriptor.set !== void 0) { return true; }\r\n\r\n   // Walk parent prototype chain. Check for descriptor at each prototype level.\r\n   for (let o = Object.getPrototypeOf(object); o; o = Object.getPrototypeOf(o))\r\n   {\r\n      const descriptor = Object.getOwnPropertyDescriptor(o, accessor);\r\n      if (descriptor !== void 0 && descriptor.set !== void 0) { return true; }\r\n   }\r\n\r\n   return false;\r\n}\n\n/**\r\n * Returns whether the target is or has the given prototype walking up the prototype chain.\r\n *\r\n * @param {*}  target - Any target to test.\r\n *\r\n * @param {Function} Prototype - Prototype function / class constructor to find.\r\n *\r\n * @returns {boolean} Target matches prototype.\r\n */\r\nfunction hasPrototype(target, Prototype)\r\n{\r\n   /* c8 ignore next */\r\n   if (typeof target !== 'function') { return false; }\r\n\r\n   if (target === Prototype) { return true; }\r\n\r\n   // Walk parent prototype chain. Check for descriptor at each prototype level.\r\n   for (let proto = Object.getPrototypeOf(target); proto; proto = Object.getPrototypeOf(proto))\r\n   {\r\n      if (proto === Prototype) { return true; }\r\n   }\r\n\r\n   return false;\r\n}\n\nfunction set(obj, key, val) {\n\tif (typeof val.value === 'object') val.value = klona(val.value);\n\tif (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === '__proto__') {\n\t\tObject.defineProperty(obj, key, val);\n\t} else obj[key] = val.value;\n}\n\nfunction klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar i=0, k, list, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\ttmp = Object.create(x.__proto__ || null);\n\t} else if (str === '[object Array]') {\n\t\ttmp = Array(x.length);\n\t} else if (str === '[object Set]') {\n\t\ttmp = new Set;\n\t\tx.forEach(function (val) {\n\t\t\ttmp.add(klona(val));\n\t\t});\n\t} else if (str === '[object Map]') {\n\t\ttmp = new Map;\n\t\tx.forEach(function (val, key) {\n\t\t\ttmp.set(klona(key), klona(val));\n\t\t});\n\t} else if (str === '[object Date]') {\n\t\ttmp = new Date(+x);\n\t} else if (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t} else if (str === '[object DataView]') {\n\t\ttmp = new x.constructor( klona(x.buffer) );\n\t} else if (str === '[object ArrayBuffer]') {\n\t\ttmp = x.slice(0);\n\t} else if (str.slice(-6) === 'Array]') {\n\t\t// ArrayBuffer.isView(x)\n\t\t// ~> `new` bcuz `Buffer.slice` => ref\n\t\ttmp = new x.constructor(x);\n\t}\n\n\tif (tmp) {\n\t\tfor (list=Object.getOwnPropertySymbols(x); i < list.length; i++) {\n\t\t\tset(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));\n\t\t}\n\n\t\tfor (i=0, list=Object.getOwnPropertyNames(x); i < list.length; i++) {\n\t\t\tif (Object.hasOwnProperty.call(tmp, k=list[i]) && tmp[k] === x[k]) continue;\n\t\t\tset(tmp, k, Object.getOwnPropertyDescriptor(x, k));\n\t\t}\n\t}\n\n\treturn tmp || x;\n}\n\nfunction isSpace(character) {\n    return character == \" \" || character == \"\\n\" || character == \"\\r\" || character == \"\\t\";\n}\nfunction isQuote(character) {\n    return character == '\"' || character == \"'\";\n}\nconst TAG_START = \"<\";\nconst TAG_END = \">\";\nconst ENCODED_TAG_START = \"&lt;\";\nconst ENCODED_TAG_END = \"&gt;\";\nclass InPlaintextState {\n    constructor(options) {\n        this.options = options;\n    }\n    consume(character, transition) {\n        if (character == TAG_START) {\n            transition(new InTagNameState(this.options));\n            return \"\";\n        }\n        else if (character == TAG_END && this.options.encodePlaintextTagDelimiters) {\n            return ENCODED_TAG_END;\n        }\n        return character;\n    }\n}\nclass InTagNameState {\n    constructor(options) {\n        this.options = options;\n        this.nameBuffer = \"\";\n        this.isClosingTag = false;\n    }\n    consume(character, transition) {\n        if (this.nameBuffer.length == 0) {\n            if (isSpace(character)) {\n                transition(new InPlaintextState(this.options));\n                return ((this.options.encodePlaintextTagDelimiters ? ENCODED_TAG_START : \"<\") +\n                    character);\n            }\n            if (character == \"/\") {\n                this.isClosingTag = true;\n                return \"\";\n            }\n        }\n        if (isSpace(character)) {\n            if (this.isNameBufferAnAllowedTag()) {\n                transition(new InTagState(0 /* TagMode.Allowed */, this.options));\n                return TAG_START + (this.isClosingTag ? \"/\" : \"\") + this.nameBuffer + character;\n            }\n            else {\n                transition(new InTagState(1 /* TagMode.Disallowed */, this.options));\n                return this.options.tagReplacementText;\n            }\n        }\n        if (character == TAG_START) {\n            this.nameBuffer += ENCODED_TAG_START;\n            return \"\";\n        }\n        if (character == TAG_END) {\n            transition(new InPlaintextState(this.options));\n            if (this.isNameBufferAnAllowedTag()) {\n                return TAG_START + (this.isClosingTag ? \"/\" : \"\") + this.nameBuffer + character;\n            }\n            else {\n                return this.options.tagReplacementText;\n            }\n        }\n        if (character == \"-\" && this.nameBuffer == \"!-\") {\n            transition(new InCommentState(this.options));\n            return \"\";\n        }\n        this.nameBuffer += character;\n        return \"\";\n    }\n    isNameBufferAnAllowedTag() {\n        const tagName = this.nameBuffer.toLowerCase();\n        if (this.options.allowedTags) {\n            return this.options.allowedTags.has(tagName);\n        }\n        else if (this.options.disallowedTags) {\n            return !this.options.disallowedTags.has(tagName);\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass InTagState {\n    constructor(mode, options) {\n        this.mode = mode;\n        this.options = options;\n    }\n    consume(character, transition) {\n        if (character == TAG_END) {\n            transition(new InPlaintextState(this.options));\n        }\n        else if (isQuote(character)) {\n            transition(new InQuotedStringInTagState(this.mode, character, this.options));\n        }\n        if (this.mode == 1 /* TagMode.Disallowed */) {\n            return \"\";\n        }\n        if (character == TAG_START) {\n            return ENCODED_TAG_START;\n        }\n        else {\n            return character;\n        }\n    }\n}\nclass InQuotedStringInTagState {\n    constructor(mode, quoteCharacter, options) {\n        this.mode = mode;\n        this.quoteCharacter = quoteCharacter;\n        this.options = options;\n    }\n    consume(character, transition) {\n        if (character == this.quoteCharacter) {\n            transition(new InTagState(this.mode, this.options));\n        }\n        if (this.mode == 1 /* TagMode.Disallowed */) {\n            return \"\";\n        }\n        if (character == TAG_START) {\n            return ENCODED_TAG_START;\n        }\n        else if (character == TAG_END) {\n            return ENCODED_TAG_END;\n        }\n        else {\n            return character;\n        }\n    }\n}\nclass InCommentState {\n    constructor(options) {\n        this.options = options;\n        this.consecutiveHyphens = 0;\n    }\n    consume(character, transition) {\n        if (character == \">\" && this.consecutiveHyphens >= 2) {\n            transition(new InPlaintextState(this.options));\n        }\n        else if (character == \"-\") {\n            this.consecutiveHyphens++;\n        }\n        else {\n            this.consecutiveHyphens = 0;\n        }\n        return \"\";\n    }\n}\n\nconst DefaultStateMachineOptions = {\n    tagReplacementText: \"\",\n    encodePlaintextTagDelimiters: true,\n};\nclass StateMachine {\n    constructor(partialOptions = {}) {\n        this.state = new InPlaintextState(Object.assign(Object.assign({}, DefaultStateMachineOptions), partialOptions));\n        this.transitionFunction = ((next) => {\n            this.state = next;\n        }).bind(this);\n    }\n    consume(text) {\n        let outputBuffer = \"\";\n        for (const character of text) {\n            outputBuffer += this.state.consume(character, this.transitionFunction);\n        }\n        return outputBuffer;\n    }\n}\nfunction striptags(text, options = {}) {\n    return new StateMachine(options).consume(text);\n}\n\nexport { A11yHelper, BrowserSupports, ClipboardAccess, ManagedPromise, TJSStyleManager, debounce, deepMerge, getStackingContext, hasAccessor, hasGetter, hasPrototype, hasSetter, hashCode, isApplicationShell, isHMRProxy, isIterable, isIterableAsync, isObject, isPlainObject, isSvelteComponent, isTJSSvelteConfig, klona, normalizeString, outroAndDestroy, parseTJSSvelteConfig, safeAccess, safeSet, striptags, styleParsePixels, uuidv4 };\n//# sourceMappingURL=index.js.map\n","import { isIterable } from '@typhonjs-svelte/lib/util';\n\n/**\r\n * Provides a readable store to track keys actively pressed. KeyStore is designed to be used with the {@link keyforward}\r\n * action.\r\n */\r\nclass KeyStore\r\n{\r\n   #keySet;\r\n\r\n   /**\r\n    * @type {Map<string, number>}\r\n    */\r\n   #keyMap = new Map();\r\n\r\n   /**\r\n    * @type {KeyStoreOptions}\r\n    */\r\n   #options = { preventDefault: true, useCode: true, stopPropagation: true };\r\n\r\n   /**\r\n    * Stores the subscribers.\r\n    *\r\n    * @type {(function(KeyStore): void)[]}\r\n    */\r\n   #subscriptions = [];\r\n\r\n   /**\r\n    * @param {Iterable<string>}  [keyNames] -\r\n    *\r\n    * @param {KeyStoreOptions}   [options] - Optional parameters\r\n    */\r\n   constructor(keyNames, options)\r\n   {\r\n      if (!isIterable(keyNames))\r\n      {\r\n         throw new TypeError(`'keyNames' is not an iterable list.`);\r\n      }\r\n\r\n      this.setOptions(options);\r\n\r\n      this.#keySet = new Set(keyNames);\r\n   }\r\n\r\n   /**\r\n    * Add given key to the tracking key set.\r\n    *\r\n    * @param {string}   key - Key to add.\r\n    */\r\n   addKey(key)\r\n   {\r\n      if (typeof key !== 'string') { throw new TypeError(`'key' is not a string.`); }\r\n\r\n      this.#keySet.add(key);\r\n   }\r\n\r\n   /**\r\n    * @returns {boolean} True if any keys in the key set are pressed.\r\n    */\r\n\r\n   /**\r\n    * Returns true if any of given keys are pressed. If `keys` is undefined then the result is true if any keys being\r\n    * tracked are pressed.\r\n    *\r\n    * @param {string|Iterable<string>|undefined} keys - Zero or more key strings or list to verify if any pressed.\r\n    *\r\n    * @returns {boolean} True if any keys set are pressed.\r\n    */\r\n   anyPressed(keys)\r\n   {\r\n      // When no keys given then check if any key is pressed.\r\n      if (keys === void 0) { return this.#keyMap.size > 0; }\r\n\r\n      const isList = isIterable(keys);\r\n\r\n      if (typeof keys !== 'string' && !isList)\r\n      {\r\n         throw new TypeError(`'keys' is not a string or iterable list of strings.`);\r\n      }\r\n\r\n      let result = false;\r\n\r\n      if (isList)\r\n      {\r\n         for (const key of keys)\r\n         {\r\n            if (this.#keyMap.has(key))\r\n            {\r\n               result = true;\r\n               break;\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         if (this.#keyMap.has(keys)) { result = true; }\r\n      }\r\n\r\n      return result;\r\n   }\r\n\r\n   /**\r\n    * Is the given key in the tracking key set.\r\n    *\r\n    * @param {string}   key - Key to check.\r\n    */\r\n   hasKey(key)\r\n   {\r\n      if (typeof key !== 'string') { throw new TypeError(`'key' is not a string.`); }\r\n\r\n      this.#keySet.has(key);\r\n   }\r\n\r\n   /**\r\n    * Returns true if all given keys are pressed.\r\n    *\r\n    * @param {string|Iterable<string>} keys - One or more key strings to verify if pressed.\r\n    *\r\n    * @returns {boolean} Are all keys pressed.\r\n    */\r\n   isPressed(keys)\r\n   {\r\n      const isList = isIterable(keys);\r\n\r\n      if (typeof keys !== 'string' && !isList)\r\n      {\r\n         throw new TypeError(`'keys' is not a string or iterable list of strings.`);\r\n      }\r\n\r\n      let result = true;\r\n\r\n      if (isList)\r\n      {\r\n         for (const key of keys)\r\n         {\r\n            if (!this.#keyMap.has(key))\r\n            {\r\n               result = false;\r\n               break;\r\n            }\r\n         }\r\n      }\r\n      else\r\n      {\r\n         if (!this.#keyMap.has(keys)) { result = false; }\r\n      }\r\n\r\n      return result;\r\n   }\r\n\r\n   /**\r\n    * Handle keydown event adding any key from the tracked key set.\r\n    *\r\n    * @param {KeyboardEvent}  event - KeyboardEvent.\r\n    */\r\n   keydown(event)\r\n   {\r\n      const key = this.#options.useCode ? event.code : event.key;\r\n\r\n      if (this.#keySet.has(key))\r\n      {\r\n         if (!this.#keyMap.has(key))\r\n         {\r\n            this.#keyMap.set(key, 1);\r\n            this._updateSubscribers();\r\n         }\r\n\r\n         if (this.#options.preventDefault) { event.preventDefault(); }\r\n         if (this.#options.stopPropagation) { event.stopPropagation(); }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * @returns {IterableIterator<string>} Returns current pressed keys iterator.\r\n    */\r\n   keysPressed()\r\n   {\r\n      return this.#keyMap.keys();\r\n   }\r\n\r\n   /**\r\n    * @returns {IterableIterator<string>} Returns currently tracked keys iterator.\r\n    */\r\n   keysTracked()\r\n   {\r\n      return this.#keySet.keys();\r\n   }\r\n\r\n   /**\r\n    * Handle keyup event removing any key from the tracked key set.\r\n    *\r\n    * @param {KeyboardEvent}  event - KeyboardEvent.\r\n    */\r\n   keyup(event)\r\n   {\r\n      const key = this.#options.useCode ? event.code : event.key;\r\n\r\n      if (this.#keySet.has(key))\r\n      {\r\n         if (this.#keyMap.has(key))\r\n         {\r\n            this.#keyMap.delete(key);\r\n            this._updateSubscribers();\r\n         }\r\n\r\n         if (this.#options.preventDefault) { event.preventDefault(); }\r\n         if (this.#options.stopPropagation) { event.stopPropagation(); }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Remove the given key from the tracking key set.\r\n    *\r\n    * @param {string}   key - Key to remove.\r\n    */\r\n   removeKey(key)\r\n   {\r\n      if (typeof key !== 'string') { throw new TypeError(`'key' is not a string.`); }\r\n\r\n      if (this.#keySet.has(key))\r\n      {\r\n         this.#keySet.delete(key);\r\n\r\n         if (this.#keyMap.has(key))\r\n         {\r\n            this.#keyMap.delete(key);\r\n            this._updateSubscribers();\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Update options.\r\n    *\r\n    * @param {KeyStoreOptions}   options - Options to set.\r\n    */\r\n   setOptions(options)\r\n   {\r\n      if (typeof options?.preventDefault === 'boolean') { this.#options.preventDefault = options.preventDefault; }\r\n      if (typeof options?.useCode === 'boolean') { this.#options.useCode = options.useCode; }\r\n      if (typeof options?.stopPropagation === 'boolean') { this.#options.stopPropagation = options.stopPropagation; }\r\n   }\r\n\r\n   /**\r\n    * @param {string}   key - key or key code to lookup.\r\n    *\r\n    * @returns {number} 1 if currently pressed and 0 if not pressed.\r\n    */\r\n   value(key)\r\n   {\r\n      return this.#keyMap.has(key) ? 1 : 0;\r\n   }\r\n\r\n   // Store subscriber implementation --------------------------------------------------------------------------------\r\n\r\n   /**\r\n    * @param {function(KeyStore): void} handler - Callback function that is invoked on update / changes.\r\n    *\r\n    * @returns {(function(): void)} Unsubscribe function.\r\n    */\r\n   subscribe(handler)\r\n   {\r\n      this.#subscriptions.push(handler); // add handler to the array of subscribers\r\n\r\n      handler(this);                     // call handler with current value\r\n\r\n      // Return unsubscribe function.\r\n      return () =>\r\n      {\r\n         const index = this.#subscriptions.findIndex((sub) => sub === handler);\r\n         if (index >= 0) { this.#subscriptions.splice(index, 1); }\r\n      };\r\n   }\r\n\r\n   /**\r\n    * Updates subscribers.\r\n    *\r\n    * @protected\r\n    */\r\n   _updateSubscribers()\r\n   {\r\n      for (let cntr = 0; cntr < this.#subscriptions.length; cntr++) { this.#subscriptions[cntr](this); }\r\n   }\r\n}\r\n\r\n/**\r\n * @typedef {object} KeyStoreOptions\r\n *\r\n * @property {boolean}  [preventDefault=true] - Invoke `preventDefault` on key events.\r\n *\r\n * @property {boolean}  [useCode=true] - When true use `event.code` otherwise use `event.key` to get active key.\r\n *\r\n * @property {boolean}  [stopPropagation=true] - Invoke `stopPropagation` on key events.\r\n */\n\n/**\r\n * Provides an action to forward on key down & up events. This can be any object that has associated `keydown` and\r\n * `keyup` methods. See {@link KeyStore} for a store implementation.\r\n *\r\n * @param {HTMLElement} node - Target element.\r\n *\r\n * @param {import('..').KeyStore}   keyStore - KeyStore to forward events key down / up events to...\r\n *\r\n * @returns {{update: (function(import('..').KeyStore): void), destroy: Function}} Action lifecycle methods.\r\n */\r\nfunction keyforward(node, keyStore)\r\n{\r\n   if (typeof keyStore?.keydown !== 'function' || typeof keyStore.keyup !== 'function')\r\n   {\r\n      throw new TypeError(`'keyStore' doesn't have required 'keydown' or 'keyup' methods.`);\r\n   }\r\n\r\n   /**\r\n    * @param {KeyboardEvent} event -\r\n    */\r\n   function onKeydown(event)\r\n   {\r\n      keyStore.keydown(event);\r\n   }\r\n\r\n   /**\r\n    * @param {KeyboardEvent} event -\r\n    */\r\n   function onKeyup(event)\r\n   {\r\n      keyStore.keyup(event);\r\n   }\r\n\r\n   /**\r\n    * Activates key listeners.\r\n    */\r\n   function activateListeners()\r\n   {\r\n      node.addEventListener('keydown', onKeydown);\r\n      node.addEventListener('keyup', onKeyup);\r\n   }\r\n\r\n   /**\r\n    * Removes key listeners.\r\n    */\r\n   function removeListeners()\r\n   {\r\n      node.removeEventListener('keydown', onKeydown);\r\n      node.removeEventListener('keyup', onKeyup);\r\n   }\r\n\r\n   activateListeners();\r\n\r\n   return {\r\n      update: (newKeyStore) =>  // eslint-disable-line no-shadow\r\n      {\r\n         keyStore = newKeyStore;\r\n\r\n         if (typeof keyStore?.keydown !== 'function' || typeof keyStore.keyup !== 'function')\r\n         {\r\n            throw new TypeError(`'newKeyStore' doesn't have required 'keydown' or 'keyup' methods.`);\r\n         }\r\n      },\r\n\r\n      destroy: () => removeListeners()\r\n   };\r\n}\n\nexport { KeyStore, keyforward };\n//# sourceMappingURL=index.js.map\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}